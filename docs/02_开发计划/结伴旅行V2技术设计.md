---
status: 已审核
version: 1.0
last_updated: 2026-01-15
reviewer: 用户
---

# 结伴旅行 V2.0 技术设计

> 基于 ZetaChain 跨链合约实现的双人结伴旅行系统技术方案。

---

## 一、系统架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              Frontend                                    │
│  ┌─────────────────┐  ┌──────────────────┐  ┌─────────────────────────┐ │
│  │ GroupTravelModal│  │ CrossChainWallet │  │ TravelDetailPage (双人) │ │
│  │   V2 (链选择)   │  │  (交易签名)      │  │  (共享探索展示)         │ │
│  └────────┬────────┘  └────────┬─────────┘  └────────────┬────────────┘ │
└───────────┼─────────────────────┼────────────────────────┼──────────────┘
            │                     │                        │
            ▼                     ▼                        ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           ZetaChain                                      │
│  ┌──────────────────────────────────────────────────────────────┐       │
│  │                    OmniTravel.sol (升级)                      │       │
│  │  ┌───────────────────────────────────────────────────────┐   │       │
│  │  │ startGroupCrossChainTravel()                          │   │       │
│  │  │ completeGroupTravel()                                 │   │       │
│  │  │ emergencyGroupReturn()                                │   │       │
│  │  └───────────────────────────────────────────────────────┘   │       │
│  └──────────────────────────────────────────────────────────────┘       │
└─────────────────────────────────────────────────────────────────────────┘
            │                     │                        │
            ▼                     ▼                        ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                              Backend                                     │
│  ┌─────────────────────┐  ┌────────────────────┐  ┌──────────────────┐  │
│  │ group-travel.routes │  │ GroupTravelService │  │ ExplorationLoop  │  │
│  │   (API 端点)        │  │   (业务逻辑)       │  │  (双人探索)      │  │
│  └─────────────────────┘  └────────────────────┘  └──────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 二、业务流程图

### 2.1 发起结伴旅行

```
●─────────────────────────────────────────────────────────────────────────●
│                      发起结伴跨链旅行流程                                │
●─────────────────────────────────────────────────────────────────────────●
│                                                                         │
│    ┌─────────┐     ┌──────────────┐     ┌────────────────┐             │
│    │ 选择好友 │ ──▶ │ 选择链/时长  │ ──▶ │ 估算干粮费用  │             │
│    └─────────┘     └──────────────┘     └───────┬────────┘             │
│                                                 │                       │
│         ┌───────────────────────────────────────┘                       │
│         ▼                                                               │
│    ┌─────────────┐     ┌───────────────┐     ┌─────────────────┐       │
│    │ 唤起钱包签名│ ──▶ │ 调用合约      │ ──▶ │ 等待交易确认   │       │
│    │ (Leader付费)│     │ startGroup... │     │                 │       │
│    └─────────────┘     └───────────────┘     └────────┬────────┘       │
│                                                       │                 │
│         ┌─────────────────────────────────────────────┘                 │
│         ▼                                                               │
│    ┌─────────────────┐     ┌────────────────┐     ┌───────────────┐    │
│    │ 后端监听事件    │ ──▶ │ 创建Travel +   │ ──▶ │ 启动探索循环  │    │
│    │ GroupTravelStart│     │ GroupTravel    │     │ (双人)        │    │
│    └─────────────────┘     └────────────────┘     └───────────────┘    │
│                                                                         │
●─────────────────────────────────────────────────────────────────────────●
```

### 2.2 探索与完成

```
●─────────────────────────────────────────────────────────────────────────●
│                      双人探索与完成流程                                  │
●─────────────────────────────────────────────────────────────────────────●
│                                                                         │
│    ┌─────────────────────────────────────────────────┐                  │
│    │                 探索循环 (每 30s)                │                  │
│    │  ┌────────────┐  ┌────────────┐  ┌────────────┐│                  │
│    │  │ Leader发现 │  │ Companion  │  │ 写入双份   ││                  │
│    │  │ 生成记录   │  │ 共享发现   │  │ Discovery  ││                  │
│    │  └────────────┘  └────────────┘  └────────────┘│                  │
│    └─────────────────────┬───────────────────────────┘                  │
│                          ▼                                              │
│    ◇──────────────────────────────────────────────────◇                │
│    │                 旅行完成?                        │                │
│    ◇──────────────────────────┬───────────────────────◇                │
│                               ▼                                         │
│    ┌────────────────┐   ┌────────────────┐   ┌────────────────┐        │
│    │ 调用合约       │──▶│ 更新两只青蛙   │──▶│ 发放 XP +      │        │
│    │ completeGroup  │   │ 状态 Idle      │   │ 友情值 +5      │        │
│    └────────────────┘   └────────────────┘   └────────────────┘        │
│                                                                         │
●─────────────────────────────────────────────────────────────────────────●
```

---

## 三、合约设计

### 3.1 新增函数

#### `startGroupCrossChainTravel`

```solidity
/**
 * @notice 发起结伴跨链旅行
 * @param leaderTokenId Leader 青蛙 tokenId
 * @param companionTokenId Companion 青蛙 tokenId
 * @param targetChainId 目标链 ID
 * @param duration 旅行时长（秒）
 */
function startGroupCrossChainTravel(
    uint256 leaderTokenId,
    uint256 companionTokenId,
    uint256 targetChainId,
    uint256 duration
) external payable whenNotPaused nonReentrant {
    // 1. 验证 Leader 是 msg.sender 的青蛙
    require(zetaFrogNFT.ownerOf(leaderTokenId) == msg.sender, "Not leader owner");
    
    // 2. 验证两只青蛙都 Idle
    require(canStartCrossChainTravel(leaderTokenId), "Leader not idle");
    require(canStartCrossChainTravel(companionTokenId), "Companion not idle");
    
    // 3. 计算干粮费 (1.5 倍社交折扣)
    uint256 durationHours = (duration + 3599) / 3600;
    uint256 singleProvisions = calculateProvisions(durationHours);
    uint256 groupProvisions = singleProvisions * 3 / 2; // 1.5x
    require(msg.value >= groupProvisions, "Insufficient provisions");
    
    // 4. 锁定 Leader NFT
    zetaFrogNFT.setFrogStatus(leaderTokenId, IZetaFrogNFT.FrogStatus.Traveling);
    
    // 5. 生成 messageId
    bytes32 messageId = keccak256(abi.encodePacked(
        leaderTokenId,
        companionTokenId,
        msg.sender,
        targetChainId,
        block.timestamp,
        _messageNonce++
    ));
    
    // 6. 存储结伴旅行信息
    groupTravels[messageId] = GroupCrossChainTravel({
        leaderTokenId: leaderTokenId,
        companionTokenId: companionTokenId,
        leaderOwner: msg.sender,
        companionOwner: zetaFrogNFT.ownerOf(companionTokenId),
        targetChainId: targetChainId,
        messageId: messageId,
        status: CrossChainStatus.Locked
    });
    
    // 7. 存储干粮
    frogProvisions[leaderTokenId] = msg.value;
    
    // 8. 发送跨链消息 (如非测试模式)
    if (!testMode) {
        _sendCrossChainMessage(targetChainId, messageId, abi.encode(
            leaderTokenId,
            companionTokenId,
            duration
        ));
    }
    
    // 9. 发送事件
    emit GroupCrossChainTravelStarted(
        leaderTokenId,
        companionTokenId,
        msg.sender,
        zetaFrogNFT.ownerOf(companionTokenId),
        targetChainId,
        messageId,
        uint64(block.timestamp),
        uint64(duration)
    );
}
```

#### `completeGroupTravel`

```solidity
/**
 * @notice 完成结伴旅行 (后端调用)
 */
function completeGroupTravel(bytes32 messageId, uint256 xpReward) external onlyTravelManager {
    GroupCrossChainTravel storage travel = groupTravels[messageId];
    require(travel.status != CrossChainStatus.None, "No travel found");
    
    // 解锁 Leader NFT
    zetaFrogNFT.setFrogStatus(travel.leaderTokenId, IZetaFrogNFT.FrogStatus.Idle);
    
    // 给两只青蛙加 XP
    if (xpReward > 0) {
        zetaFrogNFT.addExperience(travel.leaderTokenId, xpReward);
        zetaFrogNFT.addExperience(travel.companionTokenId, xpReward);
    }
    
    // 退还剩余干粮
    _refundRemainingProvisions(travel.leaderTokenId);
    
    travel.status = CrossChainStatus.Completed;
    
    emit GroupCrossChainTravelCompleted(
        travel.leaderTokenId,
        travel.companionTokenId,
        messageId,
        xpReward
    );
}
```

### 3.2 新增事件

```solidity
event GroupCrossChainTravelStarted(
    uint256 indexed leaderTokenId,
    uint256 indexed companionTokenId,
    address indexed leaderOwner,
    address companionOwner,
    uint256 targetChainId,
    bytes32 messageId,
    uint64 startTime,
    uint64 maxDuration
);

event GroupCrossChainTravelCompleted(
    uint256 indexed leaderTokenId,
    uint256 indexed companionTokenId,
    bytes32 messageId,
    uint256 xpReward
);
```

---

## 四、后端设计

### 4.1 新增服务文件

| 文件 | 说明 |
|------|------|
| `group-travel.service.ts` | 结伴旅行核心服务 |
| `group-travel.routes.ts` | API 路由 |

### 4.2 API 接口

#### POST `/api/group-travel/prepare`

准备结伴旅行（返回 gas 估算）

```typescript
// Request
{
  leaderTokenId: number;
  companionTokenId: number;
  targetChainId: number;
  duration: number; // 秒
}

// Response
{
  success: boolean;
  data: {
    estimatedProvisions: string; // wei
    estimatedProvisionsZeta: string; // 格式化
    canStart: boolean;
    leaderStatus: string;
    companionStatus: string;
    isFriend: boolean;
  }
}
```

#### POST `/api/group-travel/confirm`

确认链上交易成功后创建记录

```typescript
// Request
{
  txHash: string;
  leaderTokenId: number;
  companionTokenId: number;
  targetChainId: number;
  duration: number;
}

// Response
{
  success: boolean;
  data: {
    travelId: number;
    groupTravelId: number;
  }
}
```

### 4.3 数据库迁移

```prisma
// schema.prisma 修改 GroupTravel 模型
model GroupTravel {
  id                   Int               @id @default(autoincrement())
  leaderId             Int
  companionId          Int
  travelId             Int               @unique
  status               GroupTravelStatus @default(ACTIVE)
  createdAt            DateTime          @default(now())
  
  // V2.0 跨链新增
  isCrossChain         Boolean           @default(false)
  crossChainMessageId  String?           @unique
  targetChainId        Int?
  provisionsUsed       String?           // wei
  
  leader      Frog              @relation("GroupTravelLeader", fields: [leaderId], references: [id])
  companion   Frog              @relation("GroupTravelCompanion", fields: [companionId], references: [id])
  travel      Travel            @relation(fields: [travelId], references: [id])
  
  @@index([crossChainMessageId])
}
```

### 4.4 探索循环修改

修改 `exploration-scheduler.service.ts`，支持双人探索：

```typescript
async processGroupTravel(travelId: number, leaderFrogId: number, companionFrogId: number) {
  // 生成一次探索
  const discovery = await this.generateExploration(travelId, chainId);
  
  // 为两只青蛙都写入记录
  await this.prisma.travelDiscovery.create({
    data: {
      travelId,
      ...discovery,
      metadata: { 
        ...discovery.metadata, 
        isGroupTravel: true,
        participants: [leaderFrogId, companionFrogId]
      }
    }
  });
}
```

---

## 五、前端设计

### 5.1 修改组件

#### `GroupTravelModal.tsx` 升级

```diff
+ // 新增 props
+ interface GroupTravelModalProps {
+   // ... existing
+   isCrossChain?: boolean;  // 是否跨链模式
+ }

+ // 新增状态
+ const [targetChain, setTargetChain] = useState<ChainKey>('BSC_TESTNET');
+ const [duration, setDuration] = useState(3600); // 默认 1 小时
+ const [estimatedCost, setEstimatedCost] = useState<string | null>(null);

+ // 链选择器
<ChainSelector 
  value={targetChain} 
  onChange={setTargetChain} 
/>

+ // 时长选择器
<DurationSelector 
  value={duration} 
  onChange={setDuration} 
/>

+ // 费用显示
<ProvisionsCost 
  amount={estimatedCost} 
  isGroup={true} 
/>
```

#### 新增 `useGroupCrossChainTravel` Hook

```typescript
export function useGroupCrossChainTravel() {
  const { writeContract, data: txHash } = useWriteContract();
  
  const startGroupTravel = async (
    leaderTokenId: number,
    companionTokenId: number,
    targetChainId: number,
    duration: number,
    provisions: bigint
  ) => {
    writeContract({
      address: OMNI_TRAVEL_ADDRESS,
      abi: OmniTravelABI,
      functionName: 'startGroupCrossChainTravel',
      args: [leaderTokenId, companionTokenId, targetChainId, duration],
      value: provisions,
    });
  };
  
  return { startGroupTravel, txHash };
}
```

---

## 六、代码变更清单

### 6.1 合约层

| 操作 | 文件 | 说明 |
|------|------|------|
| MODIFY | `contracts/OmniTravel.sol` | 新增结伴旅行函数和事件 |
| MODIFY | `contracts/upgradeable/OmniTravelUpgradeable.sol` | 同步可升级版本 |

### 6.2 后端层

| 操作 | 文件 | 说明 |
|------|------|------|
| NEW | `src/services/group-travel.service.ts` | 结伴旅行服务 |
| NEW | `src/api/routes/group-travel.routes.ts` | API 路由 |
| MODIFY | `src/services/exploration-scheduler.service.ts` | 支持双人探索 |
| MODIFY | `prisma/schema.prisma` | GroupTravel 表新增字段 |

### 6.3 前端层

| 操作 | 文件 | 说明 |
|------|------|------|
| MODIFY | `src/components/travel/GroupTravelModal.tsx` | 添加链/时长选择 |
| NEW | `src/hooks/useGroupCrossChainTravel.ts` | 合约交互 Hook |
| MODIFY | `src/services/travel.api.ts` | 新增 API 调用 |

---

## 七、验证计划

### 7.1 自动化测试

```bash
# 1. 编译合约
cd contracts && npx hardhat compile

# 2. 运行合约测试
npx hardhat test test/OmniTravel.group.test.ts

# 3. 后端编译
cd ../backend && npx tsc --noEmit

# 4. 数据库迁移
npx prisma db push
```

### 7.2 手动验证

1. 使用两个钱包，各自 mint 一只青蛙
2. A 青蛙添加 B 青蛙为好友
3. A 青蛙发起结伴跨链旅行
4. 确认 A 支付 gas，两只青蛙都变为 Traveling
5. 等待旅行完成，确认两只青蛙都获得 XP

---

## 八、风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| Companion 状态不同步 | 中 | 后端监听事件后立即更新 Companion 状态 |
| 紧急返回只解锁 Leader | 高 | `emergencyGroupReturn` 同时解锁两只 |
| 干粮退还失败 | 低 | 记录失败地址，支持手动重试 |

---

## 九、变更记录

| 日期 | 版本 | 内容 |
|------|------|------|
| 2026-01-15 | 1.0 | 初始技术设计 |
