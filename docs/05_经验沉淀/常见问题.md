---
status: 已审核
version: 1.0
last_updated: 2026-01-13
reviewer: AI
---

# 常见问题与解决方案

> 本文档记录开发过程中遇到的问题和解决方案，确保不重复犯错。

## 变更记录

| 日期 | 变更内容 |
|------|----------|
| 2026-01-13 | 初始化常见问题文档 |
| 2026-01-15 | 跨链旅行状态同步问题、页面状态管理设计原则 |
| 2026-01-15 | 跨链旅行"Chain not supported"错误 - 链配置脚本遗漏 |
| 2026-01-15 | Friendship 模型字段名误用（requesterAddress → requesterId） |
| 2026-01-15 | 跨链旅行进行中无探索记录显示 |
| 2026-01-15 | 结伴旅行 tokenId=0 验证失败 - parsePositiveInt 误拒绝 |
| 2026-01-16 | OmniTravel 合约函数未同步到 Upgradeable 版本 |
| 2026-01-16 | ZRC20 地址 checksum 格式错误 |

---

## 一、前端相关

### 1.1 API 路径不一致

**问题**：前端 API 调用路径与后端路由定义不匹配

**原因**：前后端开发时未同步约定接口路径

**解决方案**：
1. 参考 `docs/API_Routes_Reference.md` 统一接口定义
2. 前端 API 调用使用统一的 `api/` 模块
3. 新增接口前先在文档中定义

---

### 1.2 TypeScript 类型错误

**问题**：类型定义与实际数据结构不匹配

**原因**：后端返回数据结构变更后未同步前端类型

**解决方案**：
1. 使用共享类型定义
2. API 响应类型与后端保持同步
3. 使用 zod 等库进行运行时类型验证

---

## 二、后端相关

### 2.1 数据库连接问题

**问题**：数据库连接超时或断开

**原因**：连接池配置不当或长时间未使用

**解决方案**：
1. 配置合理的连接池参数
2. 添加连接健康检查
3. 使用 ORM 的自动重连机制

---

## 三、智能合约相关

### 3.1 Gas 估算失败

**问题**：交易 gas 估算失败导致交易无法发送

**原因**：合约逻辑错误或状态检查未通过

**解决方案**：
1. 先使用 `callStatic` 预检查
2. 捕获并解析具体错误信息
3. 前端提示用户具体失败原因

---

## 四、桌面端相关

### 4.1 PyQt 组件显示异常

**问题**：UI 组件在某些系统上显示异常

**原因**：系统 DPI 缩放或字体问题

**解决方案**：
1. 设置高 DPI 缩放支持
2. 使用相对布局而非固定像素
3. 测试多种系统环境

---

## 五、跨模块问题

### 5.1 钱包连接状态不同步

**问题**：桌面端与 Web 端钱包连接状态不一致

**原因**：状态管理分离，未实现跨端同步

**解决方案**：
1. 使用后端统一管理会话状态
2. 实现 WebSocket 状态推送
3. 定期轮询验证状态

---

## 六、旅行系统问题

### 6.1 跨链旅行后青蛙状态不更新

**问题**：创建跨链旅行记录后，青蛙状态仍显示为 "Idle"

**原因**：`createCrossChainTravelRecord` 只创建了 `Travel` 记录，没有同步更新 `Frog.status`

**解决方案**：
```typescript
// omni-travel.service.ts
const travel = await prisma.travel.create({ ... });
await prisma.frog.update({
  where: { id: frogId },
  data: { status: 'Traveling' },
});
```

---

### 6.2 页面状态管理复杂导致 UI 不更新

**问题**：在同一页面内管理多个异步状态（pending → active → completed）导致逻辑复杂、易出错

**原因**：乐观更新 + 轮询 + WebSocket 事件多重机制互相干扰

**解决方案**：
采用页面跳转模式，旅行开始后直接跳转到 `/travel/:id` 页面：
1. 每个页面只负责一种状态
2. 从 API 拉取最新数据，无需乐观更新
3. 简化代码，提高可维护性

---

### 6.3 跨链旅行报错 "Chain not supported"

**问题**：调用 `startCrossChainTravel()` 时交易 revert，错误信息为 `Chain not supported`

**原因**：部署 OmniTravel 合约后未执行 `configure-omnitravel-proxy.js` 脚本，导致 `supportedChains[97]` 和 `supportedChains[11155111]` 未被设置为 `true`

**解决方案**：
```bash
cd contracts
npx hardhat run scripts/configure-omnitravel-proxy.js --network zetaAthens
```

**预防措施**：
- `/重置` 工作流中已添加步骤 3.4，确保每次重新部署时执行此脚本
- 合约部署脚本 `deploy-upgradeable-all.js` 应考虑自动调用链配置

---

### 6.4 跨链旅行进行中无探索记录显示

**问题**：跨链旅行页面在旅行进行中不显示"链上发现"内容，但本地探索可以正常显示

**原因**：本地旅行使用 `travelProcessor.processTravel()` 在旅行进行中实时生成探索记录，而跨链旅行仅在 `completeCrossChainTravel()` 时一次性生成，导致进行中时 `TravelDiscovery` 表为空

**解决方案**：
在 `omni-travel.service.ts` 的 `onFrogArrivedAtTarget()` 中添加新方法 `startCrossChainExploration()`，在 `ON_TARGET_CHAIN` 阶段每 30 秒生成一条探索记录

**关键点**：
- 探索循环在 `crossChainStatus` 变化时自动停止
- 同时生成 `TravelInteraction` 和 `TravelDiscovery` 记录
- 前端通过 `/api/cross-chain/travel/:travelId/discoveries` 获取数据

---

## 七、数据库/Prisma 问题

### 7.1 Friendship 模型字段名误用

**问题**：好友界面加载报错 `Unknown argument 'requesterAddress'`

**原因**：`crosschain-transfer.service.ts` 中错误使用了 `requesterAddress`/`addresseeAddress` 字段查询 Friendship，但 Prisma Schema 中 Friendship 模型使用的是 `requesterId`/`addresseeId`（关联到 Frog 表的 id）

**错误代码**：
```typescript
// ❌ 错误
const friendships = await prisma.friendship.findMany({
  where: {
    OR: [
      { requesterAddress: frog.ownerAddress, status: 'ACCEPTED' },
      { addresseeAddress: frog.ownerAddress, status: 'ACCEPTED' },
    ],
  },
  include: {
    requesterFrog: true,  // ❌ 不存在
    addresseeFrog: true,  // ❌ 不存在
  },
});
```

**正确代码**：
```typescript
// ✅ 正确
const friendships = await prisma.friendship.findMany({
  where: {
    OR: [
      { requesterId: frogId, status: 'Accepted' },  // 注意：用 frogId，状态值大小写
      { addresseeId: frogId, status: 'Accepted' },
    ],
  },
  include: {
    requester: true,  // ✅ 正确的关联名
    addressee: true,  // ✅ 正确的关联名
  },
});
```

**关键点**：
1. `Friendship` 通过 `requesterId`/`addresseeId` 关联 `Frog.id`，不存在 Address 字段
2. 关联名是 `requester`/`addressee`，不是 `requesterFrog`/`addresseeFrog`
3. 状态值枚举是 `'Accepted'`（首字母大写），不是 `'ACCEPTED'`

---

### 6.5 结伴旅行 tokenId=0 验证失败

**问题**：结伴旅行报错 `leaderId and companionId must be valid positive integers`

**原因**：`travel.routes.ts` 使用 `parsePositiveInt()` 验证 tokenId，该函数检查 `parsed <= 0` 时返回 `null`，导致 tokenId=0（第一个铸造的 NFT）被错误拒绝

**错误代码**：
```typescript
// ❌ validation.ts
export function parsePositiveInt(value: any): number | null {
    if (isNaN(parsed) || parsed <= 0) return null;  // tokenId=0 被拒绝
}
```

**解决方案**：添加 `parseNonNegativeInt()` 函数，允许 0 作为有效值：
```typescript
// ✅ 新增函数
export function parseNonNegativeInt(value: any): number | null {
    if (value === undefined || value === null) return null;
    const parsed = parseInt(value, 10);
    if (isNaN(parsed) || parsed < 0) return null;  // 仅拒绝负数
    return parsed;
}
```

**关键点**：
1. NFT tokenId 从 0 开始计数，0 是合法值
2. 验证函数需区分"正整数"和"非负整数"场景
3. 类似场景：所有接收 tokenId 的接口都应使用 `parseNonNegativeInt`

---

### 4.7 OmniTravel 合约函数未同步到 Upgradeable 版本

**问题**：调用 `startGroupCrossChainTravel` 合约函数失败，提示 "missing revert data"

**原因**：新函数只添加到了 `OmniTravel.sol`，但部署使用的是 `OmniTravelUpgradeable.sol`，两个合约文件不同步

**解决方案**：
1. 将新函数复制到 `contracts/upgradeable/OmniTravelUpgradeable.sol`
2. 重新编译合约
3. 使用 UUPS 升级脚本升级代理合约

```bash
npx hardhat compile
npx hardhat run scripts/upgrade-omnitravel.js --network zetaAthens
```

**关键点**：
1. 项目同时存在普通版和 Upgradeable 版合约，修改时需同步
2. UUPS 代理合约升级后，代理地址不变，实现地址更新
3. 建议：统一只使用一个版本，避免不同步问题

---

### 4.8 ZRC20 地址 checksum 格式错误

**问题**：配置链时报错 "bad address checksum"

**原因**：以太坊地址有大小写校验（EIP-55 checksum），手动输入的地址可能校验和不正确

**解决方案**：使用 `ethers.getAddress()` 标准化地址格式：

```javascript
// ✅ 正确做法
const zrc20 = hre.ethers.getAddress("0x48f80608B672DC30DC7e3dbBd0343c5F02C738Eb");

// ❌ 错误做法 - 直接使用字符串可能校验和错误
const zrc20 = "0x48f80608b672dc30dc7e3dbbd0343c5f02c738eb";
```

**关键点**：
1. 从区块链浏览器复制地址时注意保留原始大小写
2. 使用 `ethers.getAddress()` 或 `ethers.utils.getAddress()` 自动修正
3. 测试网 ZRC20 地址可从 ZetaChain 官方文档获取

---
