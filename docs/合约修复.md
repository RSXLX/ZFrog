# ğŸ¯ ä¿®æ”¹æ™ºèƒ½åˆçº¦ï¼ˆå®Œæ•´æ–¹æ¡ˆï¼‰

## ğŸ“‹ æ–¹æ¡ˆæ¦‚è¿°

**æ ¸å¿ƒæ€è·¯**ï¼šå…è®¸åˆçº¦æ¥å—é›¶åœ°å€ä½œä¸ºéšæœºæ¢ç´¢çš„æ ‡è¯†ï¼Œä¿æŒåŸæœ‰çš„åç«¯æµç¨‹ä¸å˜ã€‚

**ä¼˜ç‚¹**ï¼š
- âœ… æœ€å°åŒ–ä»£ç æ”¹åŠ¨
- âœ… ä¿æŒåç«¯é€»è¾‘ä¸€è‡´æ€§
- âœ… èŠ‚çœ Gasï¼ˆé›¶åœ°å€æ›´çœï¼‰
- âœ… ç¬¦åˆåŸå§‹è®¾è®¡æ„å›¾

**ç¼ºç‚¹**ï¼š
- âš ï¸ éœ€è¦é‡æ–°éƒ¨ç½²åˆçº¦
- âš ï¸ å¦‚æœåˆçº¦å·²éƒ¨ç½²åˆ°ä¸»ç½‘ï¼Œéœ€è¦å‡çº§æ–¹æ¡ˆ

---

## ğŸ”§ å…·ä½“ä¿®æ”¹å†…å®¹

### **1. ä¿®æ”¹æ™ºèƒ½åˆçº¦ ZetaFrogNFT.sol**

**æ–‡ä»¶ä½ç½®**ï¼š`contracts/contracts/ZetaFrogNFT.sol`

#### **ä¿®æ”¹ç‚¹ 1ï¼šåˆ é™¤é›¶åœ°å€éªŒè¯**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

contract ZetaFrogNFT is ERC721URIStorage, Ownable, ReentrancyGuard, Pausable {
    // ... å…¶ä»–ä»£ç ä¿æŒä¸å˜ ...

    /**
     * @notice Start a travel journey
     * @param tokenId Frog NFT ID
     * @param targetWallet Wallet address to observe (can be address(0) for random exploration)
     * @param duration Travel duration in seconds
     */
    function startTravel(
        uint256 tokenId,
        address targetWallet,
        uint256 duration
    ) external whenNotPaused nonReentrant onlyFrogOwner(tokenId) {
        Frog storage frog = frogs[tokenId];
        
        // Validations
        require(frog.status == FrogStatus.Idle, "Frog is busy");
        
        // âœ… ä¿®æ”¹ï¼šå…è®¸é›¶åœ°å€ç”¨äºéšæœºæ¢ç´¢
        // âŒ åˆ é™¤è¿™è¡Œï¼šrequire(targetWallet != address(0), "Invalid target");
        // âœ… é›¶åœ°å€è¡¨ç¤ºéšæœºæ¢ç´¢ï¼Œç”±åç«¯æœåŠ¡åŠ¨æ€å‘ç°ç›®æ ‡åœ°å€
        
        require(duration >= MIN_TRAVEL_DURATION, "Duration too short");
        require(duration <= MAX_TRAVEL_DURATION, "Duration too long");
        require(
            block.timestamp >= lastTravelEnd[tokenId] + COOLDOWN_PERIOD,
            "Still in cooldown"
        );
        
        // Update state
        frog.status = FrogStatus.Traveling;
        
        uint64 startTime = uint64(block.timestamp);
        uint64 endTime = uint64(block.timestamp + duration);
        
        activeTravels[tokenId] = Travel({
            startTime: startTime,
            endTime: endTime,
            targetWallet: targetWallet,  // âœ… å¯ä»¥æ˜¯é›¶åœ°å€
            completed: false
        });
        
        emit TravelStarted(tokenId, targetWallet, startTime, endTime);
    }
    
    // ... å…¶ä»–å‡½æ•°ä¿æŒä¸å˜ ...
}
```

#### **ä¿®æ”¹ç‚¹ 2ï¼šæ›´æ–° Travel ç»“æ„ä½“æ³¨é‡Šï¼ˆå¯é€‰ï¼‰**

```solidity
// ============ Structs ============
struct Travel {
    uint64 startTime;
    uint64 endTime;
    address targetWallet;  // âœ… æ³¨é‡Šï¼šåœ°å€ä¸º 0x0 æ—¶è¡¨ç¤ºéšæœºæ¢ç´¢
    bool completed;
}
```

#### **ä¿®æ”¹ç‚¹ 3ï¼šæ›´æ–°äº‹ä»¶æ–‡æ¡£ï¼ˆå¯é€‰ä½†æ¨èï¼‰**

```solidity
/**
 * @notice Emitted when a frog starts traveling
 * @param tokenId The frog's token ID
 * @param targetWallet The target wallet address (0x0 for random exploration)
 * @param startTime Travel start timestamp
 * @param endTime Expected travel end timestamp
 */
event TravelStarted(
    uint256 indexed tokenId,
    address indexed targetWallet,
    uint64 startTime,
    uint64 endTime
);
```

---

### **2. åˆçº¦éƒ¨ç½²è„šæœ¬ï¼ˆå¦‚æœéœ€è¦é‡æ–°éƒ¨ç½²ï¼‰**

**æ–‡ä»¶ä½ç½®**ï¼š`contracts/scripts/deploy.js`

```javascript
// scripts/deploy.js

const hre = require("hardhat");

async function main() {
    console.log("ğŸ¸ Deploying ZetaFrog contracts...");

    // 1. éƒ¨ç½² ZetaFrogNFT
    const ZetaFrogNFT = await hre.ethers.getContractFactory("ZetaFrogNFT");
    const zetaFrogNFT = await ZetaFrogNFT.deploy();
    await zetaFrogNFT.deployed();
    
    console.log("âœ… ZetaFrogNFT deployed to:", zetaFrogNFT.address);

    // 2. éƒ¨ç½² SouvenirNFT
    const SouvenirNFT = await hre.ethers.getContractFactory("SouvenirNFT");
    const souvenirNFT = await SouvenirNFT.deploy();
    await souvenirNFT.deployed();
    
    console.log("âœ… SouvenirNFT deployed to:", souvenirNFT.address);

    // 3. é…ç½®åˆçº¦å…³è”
    await zetaFrogNFT.setSouvenirNFT(souvenirNFT.address);
    console.log("âœ… SouvenirNFT address set in ZetaFrogNFT");

    await souvenirNFT.setZetaFrogNFT(zetaFrogNFT.address);
    console.log("âœ… ZetaFrogNFT address set in SouvenirNFT");

    // 4. è®¾ç½®åç«¯ TravelManager åœ°å€
    const travelManagerAddress = process.env.TRAVEL_MANAGER_ADDRESS;
    if (travelManagerAddress) {
        await zetaFrogNFT.setTravelManager(travelManagerAddress);
        console.log("âœ… TravelManager address set:", travelManagerAddress);
    }

    // 5. éªŒè¯åˆçº¦ï¼ˆå¯é€‰ï¼‰
    console.log("\nğŸ“ Contract addresses:");
    console.log("ZetaFrogNFT:", zetaFrogNFT.address);
    console.log("SouvenirNFT:", souvenirNFT.address);
    
    // 6. ä¿å­˜åœ°å€åˆ°é…ç½®æ–‡ä»¶
    const fs = require('fs');
    const addresses = {
        ZetaFrogNFT: zetaFrogNFT.address,
        SouvenirNFT: souvenirNFT.address,
        network: hre.network.name,
        deployedAt: new Date().toISOString()
    };
    
    fs.writeFileSync(
        './deployed-addresses.json',
        JSON.stringify(addresses, null, 2)
    );
    
    console.log("\nâœ… Deployment complete!");
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
```

**è¿è¡Œéƒ¨ç½²**ï¼š

```bash
# éƒ¨ç½²åˆ° ZetaChain Athens Testnet
cd contracts
npx hardhat run scripts/deploy.js --network zetaAthens

# æˆ–éƒ¨ç½²åˆ°æœ¬åœ°æµ‹è¯•ç½‘
npx hardhat run scripts/deploy.js --network localhost
```

---

### **3. æ›´æ–°å‰ç«¯é…ç½®ï¼ˆä½¿ç”¨æ–°åˆçº¦åœ°å€ï¼‰**

**æ–‡ä»¶ä½ç½®**ï¼š`frontend/.env`

```bash
# æ›´æ–°åˆçº¦åœ°å€
VITE_ZETAFROG_NFT_ADDRESS=0xæ–°éƒ¨ç½²çš„åˆçº¦åœ°å€
VITE_SOUVENIR_NFT_ADDRESS=0xæ–°éƒ¨ç½²çš„çºªå¿µå“åˆçº¦åœ°å€

# å…¶ä»–é…ç½®ä¿æŒä¸å˜
VITE_API_URL=http://localhost:3001
VITE_WS_URL=http://localhost:3001
VITE_WALLETCONNECT_PROJECT_ID=your_project_id
```

---

### **4. æ›´æ–°åç«¯é…ç½®ï¼ˆä½¿ç”¨æ–°åˆçº¦åœ°å€ï¼‰**

**æ–‡ä»¶ä½ç½®**ï¼š`backend/.env`

```bash
# æ›´æ–°åˆçº¦åœ°å€
ZETAFROG_NFT_ADDRESS=0xæ–°éƒ¨ç½²çš„åˆçº¦åœ°å€
SOUVENIR_NFT_ADDRESS=0xæ–°éƒ¨ç½²çš„çºªå¿µå“åˆçº¦åœ°å€

# ZetaChain RPC
ZETACHAIN_RPC=https://zetachain-athens.blockpi.network/v1/rpc/public

# åç«¯é’±åŒ…ç§é’¥ï¼ˆTravelManagerï¼‰
PRIVATE_KEY=your_private_key_here

# å…¶ä»–é…ç½®
DATABASE_URL=postgresql://username:password@localhost:5432/zetafrog
QWEN_API_KEY=your_qwen_api_key
PINATA_API_KEY=your_pinata_api_key
```

---

### **5. éªŒè¯åˆçº¦åŠŸèƒ½ï¼ˆæµ‹è¯•è„šæœ¬ï¼‰**

**æ–‡ä»¶ä½ç½®**ï¼š`contracts/scripts/test-random-travel.js`

```javascript
// scripts/test-random-travel.js

const hre = require("hardhat");

async function main() {
    console.log("ğŸ§ª Testing Random Travel Functionality...\n");

    const [owner] = await hre.ethers.getSigners();
    console.log("Testing with account:", owner.address);

    // 1. è¿æ¥åˆ°å·²éƒ¨ç½²çš„åˆçº¦
    const zetaFrogAddress = process.env.ZETAFROG_NFT_ADDRESS;
    const ZetaFrogNFT = await hre.ethers.getContractFactory("ZetaFrogNFT");
    const frogNFT = ZetaFrogNFT.attach(zetaFrogAddress);

    console.log("Connected to ZetaFrogNFT at:", zetaFrogAddress);

    // 2. é“¸é€ ä¸€åªæµ‹è¯•é’è›™
    console.log("\nğŸ“ Minting a test frog...");
    const mintTx = await frogNFT.mintFrog("TestFrog");
    const mintReceipt = await mintTx.wait();
    
    const mintEvent = mintReceipt.events.find(e => e.event === 'FrogMinted');
    const tokenId = mintEvent.args.tokenId;
    
    console.log("âœ… Frog minted! Token ID:", tokenId.toString());

    // 3. æµ‹è¯•éšæœºæ¢ç´¢ï¼ˆé›¶åœ°å€ï¼‰
    console.log("\nğŸ² Testing random travel with zero address...");
    
    const zeroAddress = "0x0000000000000000000000000000000000000000";
    const duration = 3600; // 1 hour
    
    try {
        const travelTx = await frogNFT.startTravel(tokenId, zeroAddress, duration);
        const travelReceipt = await travelTx.wait();
        
        console.log("âœ… Random travel started successfully!");
        console.log("Transaction hash:", travelTx.hash);
        
        // æ£€æŸ¥äº‹ä»¶
        const travelEvent = travelReceipt.events.find(e => e.event === 'TravelStarted');
        console.log("\nğŸ“Š Travel Details:");
        console.log("Token ID:", travelEvent.args.tokenId.toString());
        console.log("Target Wallet:", travelEvent.args.targetWallet);
        console.log("Start Time:", new Date(travelEvent.args.startTime * 1000).toISOString());
        console.log("End Time:", new Date(travelEvent.args.endTime * 1000).toISOString());
        
        // 4. éªŒè¯é’è›™çŠ¶æ€
        const activeTravel = await frogNFT.getActiveTravel(tokenId);
        console.log("\nğŸ¸ Frog Status:");
        console.log("Is traveling:", activeTravel.targetWallet === zeroAddress);
        console.log("Target:", activeTravel.targetWallet);
        console.log("Completed:", activeTravel.completed);
        
        console.log("\nâœ… All tests passed! Zero address is accepted for random travel.");
        
    } catch (error) {
        console.error("\nâŒ Test failed!");
        console.error("Error:", error.message);
        
        if (error.message.includes("Invalid target")) {
            console.error("\nâš ï¸  The contract still rejects zero address!");
            console.error("Please ensure you deployed the updated contract.");
        }
        
        process.exit(1);
    }

    // 5. æµ‹è¯•æ™®é€šæ—…è¡Œï¼ˆéé›¶åœ°å€ï¼‰
    console.log("\nğŸ§ª Testing normal travel with valid address...");
    
    // ç­‰å¾…å†·å´æ—¶é—´
    console.log("Waiting for cooldown period...");
    await new Promise(resolve => setTimeout(resolve, 11000)); // 11 seconds
    
    const testAddress = "0x1234567890123456789012345678901234567890";
    
    try {
        const normalTravelTx = await frogNFT.startTravel(tokenId, testAddress, duration);
        await normalTravelTx.wait();
        console.log("âœ… Normal travel also works!");
        
    } catch (error) {
        console.error("âŒ Normal travel failed:", error.message);
    }

    console.log("\nâœ… Testing complete!");
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
```

**è¿è¡Œæµ‹è¯•**ï¼š

```bash
cd contracts
ZETAFROG_NFT_ADDRESS=0xä½ çš„åˆçº¦åœ°å€ npx hardhat run scripts/test-random-travel.js --network zetaAthens
```

---

### **6. åˆçº¦å•å…ƒæµ‹è¯•**

**æ–‡ä»¶ä½ç½®**ï¼š`contracts/test/ZetaFrogNFT.test.js`

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("ZetaFrogNFT - Random Travel", function () {
    let zetaFrogNFT;
    let owner;
    let addr1;

    beforeEach(async function () {
        [owner, addr1] = await ethers.getSigners();
        
        const ZetaFrogNFT = await ethers.getContractFactory("ZetaFrogNFT");
        zetaFrogNFT = await ZetaFrogNFT.deploy();
        await zetaFrogNFT.deployed();
    });

    describe("Random Travel with Zero Address", function () {
        it("Should accept zero address for random travel", async function () {
            // Mint a frog
            await zetaFrogNFT.mintFrog("TestFrog");
            const tokenId = 0;

            // Start random travel with zero address
            const zeroAddress = ethers.constants.AddressZero;
            const duration = 3600; // 1 hour

            await expect(
                zetaFrogNFT.startTravel(tokenId, zeroAddress, duration)
            ).to.not.be.reverted;
        });

        it("Should emit TravelStarted event with zero address", async function () {
            await zetaFrogNFT.mintFrog("TestFrog");
            const tokenId = 0;

            const zeroAddress = ethers.constants.AddressZero;
            const duration = 3600;

            await expect(
                zetaFrogNFT.startTravel(tokenId, zeroAddress, duration)
            )
                .to.emit(zetaFrogNFT, "TravelStarted")
                .withArgs(tokenId, zeroAddress, anyValue, anyValue);
        });

        it("Should update frog status to Traveling", async function () {
            await zetaFrogNFT.mintFrog("TestFrog");
            const tokenId = 0;

            await zetaFrogNFT.startTravel(
                tokenId,
                ethers.constants.AddressZero,
                3600
            );

            const frog = await zetaFrogNFT.getFrog(tokenId);
            expect(frog.status).to.equal(1); // 1 = Traveling
        });

        it("Should store zero address in activeTravel", async function () {
            await zetaFrogNFT.mintFrog("TestFrog");
            const tokenId = 0;

            const zeroAddress = ethers.constants.AddressZero;
            await zetaFrogNFT.startTravel(tokenId, zeroAddress, 3600);

            const activeTravel = await zetaFrogNFT.getActiveTravel(tokenId);
            expect(activeTravel.targetWallet).to.equal(zeroAddress);
            expect(activeTravel.completed).to.be.false;
        });
    });

    describe("Normal Travel with Valid Address", function () {
        it("Should accept valid non-zero address", async function () {
            await zetaFrogNFT.mintFrog("TestFrog");
            const tokenId = 0;

            const validAddress = addr1.address;
            await expect(
                zetaFrogNFT.startTravel(tokenId, validAddress, 3600)
            ).to.not.be.reverted;
        });
    });

    describe("Travel Validations", function () {
        it("Should reject travel when frog is already traveling", async function () {
            await zetaFrogNFT.mintFrog("TestFrog");
            const tokenId = 0;

            // Start first travel
            await zetaFrogNFT.startTravel(
                tokenId,
                ethers.constants.AddressZero,
                3600
            );

            // Try to start second travel
            await expect(
                zetaFrogNFT.startTravel(
                    tokenId,
                    addr1.address,
                    3600
                )
            ).to.be.revertedWith("Frog is busy");
        });

        it("Should reject travel with duration too short", async function () {
            await zetaFrogNFT.mintFrog("TestFrog");
            const tokenId = 0;

            await expect(
                zetaFrogNFT.startTravel(
                    tokenId,
                    ethers.constants.AddressZero,
                    1800 // 30 minutes, less than MIN_TRAVEL_DURATION (1 hour)
                )
            ).to.be.revertedWith("Duration too short");
        });

        it("Should reject travel with duration too long", async function () {
            await zetaFrogNFT.mintFrog("TestFrog");
            const tokenId = 0;

            const duration = 25 * 60 * 60; // 25 hours, more than MAX (24 hours)
            
            await expect(
                zetaFrogNFT.startTravel(
                    tokenId,
                    ethers.constants.AddressZero,
                    duration
                )
            ).to.be.revertedWith("Duration too long");
        });
    });
});
```

**è¿è¡Œæµ‹è¯•**ï¼š

```bash
cd contracts
npx hardhat test
```

---

### **7. æ›´æ–°åç«¯åˆçº¦äº¤äº’ä»£ç ï¼ˆç¡®ä¿å…¼å®¹ï¼‰**

**æ–‡ä»¶ä½ç½®**ï¼š`backend/src/contracts/ZetaFrogNFT.ts`

```typescript
// backend/src/contracts/ZetaFrogNFT.ts

import { ethers } from 'ethers';
import ZetaFrogNFTABI from './abis/ZetaFrogNFT.json';

export class ZetaFrogNFTContract {
    private contract: ethers.Contract;
    private provider: ethers.providers.Provider;
    private signer: ethers.Signer;

    constructor(
        contractAddress: string,
        provider: ethers.providers.Provider,
        signer: ethers.Signer
    ) {
        this.provider = provider;
        this.signer = signer;
        this.contract = new ethers.Contract(
            contractAddress,
            ZetaFrogNFTABI,
            signer
        );
    }

    /**
     * å¼€å§‹æ—…è¡Œ
     * @param tokenId é’è›™ NFT ID
     * @param targetWallet ç›®æ ‡é’±åŒ…åœ°å€ï¼ˆå¯ä»¥æ˜¯é›¶åœ°å€ç”¨äºéšæœºæ¢ç´¢ï¼‰
     * @param duration æ—…è¡Œæ—¶é•¿ï¼ˆç§’ï¼‰
     */
    async startTravel(
        tokenId: number,
        targetWallet: string,
        duration: number
    ): Promise<ethers.ContractTransaction> {
        try {
            // âœ… æ”¯æŒé›¶åœ°å€
            const tx = await this.contract.startTravel(
                tokenId,
                targetWallet, // å¯ä»¥æ˜¯ 0x0000000000000000000000000000000000000000
                duration,
                {
                    gasLimit: 200000, // è®¾ç½®åˆç†çš„ gas limit
                }
            );

            console.log(`Travel started for frog #${tokenId}`);
            console.log(`Target: ${targetWallet}`);
            console.log(`Tx hash: ${tx.hash}`);

            return tx;
        } catch (error: any) {
            console.error('Failed to start travel:', error.message);
            throw new Error(`Contract call failed: ${error.message}`);
        }
    }

    /**
     * å®Œæˆæ—…è¡Œï¼ˆç”±åç«¯ TravelManager è°ƒç”¨ï¼‰
     */
    async completeTravel(
        tokenId: number,
        journalHash: string,
        souvenirId: number
    ): Promise<ethers.ContractTransaction> {
        const tx = await this.contract.completeTravel(
            tokenId,
            journalHash,
            souvenirId
        );
        return tx;
    }

    /**
     * å–æ¶ˆæ—…è¡Œ
     */
    async cancelTravel(tokenId: number): Promise<ethers.ContractTransaction> {
        const tx = await this.contract.cancelTravel(tokenId);
        return tx;
    }

    /**
     * è·å–é’è›™ä¿¡æ¯
     */
    async getFrog(tokenId: number) {
        const frog = await this.contract.getFrog(tokenId);
        return {
            name: frog.name,
            birthday: frog.birthday.toNumber(),
            totalTravels: frog.totalTravels,
            status: frog.status, // 0: Idle, 1: Traveling, 2: Returning
        };
    }

    /**
     * è·å–æ´»è·ƒæ—…è¡Œä¿¡æ¯
     */
    async getActiveTravel(tokenId: number) {
        const travel = await this.contract.getActiveTravel(tokenId);
        return {
            startTime: travel.startTime.toNumber(),
            endTime: travel.endTime.toNumber(),
            targetWallet: travel.targetWallet,
            completed: travel.completed,
        };
    }

    /**
     * æ£€æŸ¥é’è›™æ˜¯å¦å¯ä»¥æ—…è¡Œ
     */
    async canTravel(tokenId: number): Promise<boolean> {
        return await this.contract.canTravel(tokenId);
    }
}
```

---

### **8. API è·¯ç”±ä¿æŒä¸å˜ï¼ˆéªŒè¯å…¼å®¹æ€§ï¼‰**

**æ–‡ä»¶ä½ç½®**ï¼š`backend/src/api/routes/travel.routes.ts`

```typescript
// backend/src/api/routes/travel.routes.ts

router.post('/start', async (req, res) => {
    try {
        const { frogId, travelType = 'RANDOM', targetChain, targetAddress, duration } = req.body;
        const userId = req.user.id; // ä»è®¤è¯ä¸­é—´ä»¶è·å–

        // éªŒè¯å‚æ•°
        if (!frogId || !targetChain || !duration) {
            return res.status(400).json({
                success: false,
                error: { code: 1001, message: 'Missing required parameters' }
            });
        }

        // è·å–é’è›™ä¿¡æ¯
        const frog = await prisma.frog.findUnique({
            where: { id: frogId, userId }
        });

        if (!frog || !frog.tokenId) {
            return res.status(404).json({
                success: false,
                error: { code: 2001, message: 'Frog not found or not minted' }
            });
        }

        // âœ… å¯¹äºéšæœºæ¢ç´¢ï¼Œä½¿ç”¨é›¶åœ°å€
        let contractTargetAddress = targetAddress;
        if (travelType === 'RANDOM' && !targetAddress) {
            contractTargetAddress = '0x0000000000000000000000000000000000000000';
        }

        // åˆ›å»ºæ—…è¡Œè®°å½•
        const travel = await prisma.travel.create({
            data: {
                userId,
                frogId,
                targetChain,
                targetAddress: contractTargetAddress,
                isRandom: travelType === 'RANDOM',
                duration,
                status: 'PENDING',
                currentStage: 'PREPARING',
                progress: 0,
            }
        });

        // âœ… è°ƒç”¨åˆçº¦ï¼ˆæ”¯æŒé›¶åœ°å€ï¼‰
        const frogContract = new ZetaFrogNFTContract(
            process.env.ZETAFROG_NFT_ADDRESS!,
            provider,
            signer
        );

        const tx = await frogContract.startTravel(
            frog.tokenId,
            contractTargetAddress, // å¯ä»¥æ˜¯é›¶åœ°å€
            duration
        );

        await tx.wait();

        // æ›´æ–°æ—…è¡ŒçŠ¶æ€
        await prisma.travel.update({
            where: { id: travel.id },
            data: {
                status: 'IN_PROGRESS',
                txHash: tx.hash,
            }
        });

        // åŠ å…¥å¤„ç†é˜Ÿåˆ—
        await travelQueue.add('process-travel', {
            travelId: travel.id
        });

        res.json({
            success: true,
            data: {
                travelId: travel.id,
                txHash: tx.hash
            }
        });

    } catch (error: any) {
        console.error('Failed to start travel:', error);
        res.status(500).json({
            success: false,
            error: {
                code: 1000,
                message: error.message || 'Failed to start travel'
            }
        });
    }
});
```

---

## ğŸ“¦ å®Œæ•´éƒ¨ç½²æµç¨‹

### **Step 1: ç¼–è¯‘åˆçº¦**

```bash
cd contracts
npm install
npx hardhat compile
```

### **Step 2: è¿è¡Œæµ‹è¯•**

```bash
npx hardhat test
```

### **Step 3: éƒ¨ç½²åˆ°æµ‹è¯•ç½‘**

```bash
# é…ç½® hardhat.config.js
npx hardhat run scripts/deploy.js --network zetaAthens
```

### **Step 4: ä¿å­˜åˆçº¦åœ°å€**

éƒ¨ç½²åä¼šç”Ÿæˆ `deployed-addresses.json`ï¼ŒåŒ…å«ï¼š

```json
{
  "ZetaFrogNFT": "0xABC...",
  "SouvenirNFT": "0xDEF...",
  "network": "zetaAthens",
  "deployedAt": "2025-12-20T18:00:00.000Z"
}
```

### **Step 5: æ›´æ–°å‰åç«¯é…ç½®**

```bash
# æ›´æ–°å‰ç«¯ .env
cd frontend
echo "VITE_ZETAFROG_NFT_ADDRESS=0xABC..." >> .env

# æ›´æ–°åç«¯ .env
cd backend
echo "ZETAFROG_NFT_ADDRESS=0xABC..." >> .env
```

### **Step 6: éªŒè¯åŠŸèƒ½**

```bash
cd contracts
ZETAFROG_NFT_ADDRESS=0xABC... npx hardhat run scripts/test-random-travel.js --network zetaAthens
```

### **Step 7: å¯åŠ¨åç«¯æœåŠ¡**

```bash
cd backend
npm run dev
```

### **Step 8: æµ‹è¯•éšæœºæ¢ç´¢**

ä½¿ç”¨å‰ç«¯æˆ– API æµ‹è¯•å·¥å…·å‘èµ·éšæœºæ¢ç´¢è¯·æ±‚ï¼ŒéªŒè¯é›¶åœ°å€æ˜¯å¦è¢«æ¥å—ã€‚

---

## âœ… éªŒè¯æ¸…å•

- [ ] åˆçº¦ç¼–è¯‘æˆåŠŸ
- [ ] å•å…ƒæµ‹è¯•å…¨éƒ¨é€šè¿‡
- [ ] åˆçº¦éƒ¨ç½²åˆ°æµ‹è¯•ç½‘æˆåŠŸ
- [ ] é›¶åœ°å€éšæœºæ¢ç´¢æµ‹è¯•é€šè¿‡
- [ ] æ™®é€šæ—…è¡ŒåŠŸèƒ½æ­£å¸¸
- [ ] å‰åç«¯é…ç½®å·²æ›´æ–°
- [ ] API æ¥å£æµ‹è¯•é€šè¿‡
- [ ] ç«¯åˆ°ç«¯æµ‹è¯•é€šè¿‡

--