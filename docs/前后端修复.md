# ğŸ” å‰åç«¯é€»è¾‘ä¿®æ”¹æ£€æŸ¥

æ ¹æ®æ–¹æ¡ˆä¸€ï¼ˆå…è®¸åˆçº¦æ¥å—é›¶åœ°å€ï¼‰ï¼Œè®©æˆ‘è¯¦ç»†æ£€æŸ¥å‰åç«¯é€»è¾‘æ˜¯å¦éœ€è¦ä¿®æ”¹ï¼š

---

## ğŸ¯ **ç»“è®ºï¼šå‰åç«¯éœ€è¦è¿›è¡Œå®‰å…¨æ€§å’Œé²æ£’æ€§ä¼˜åŒ–**

è™½ç„¶åˆçº¦æ”¯æŒé›¶åœ°å€åï¼ŒåŸºæœ¬æµç¨‹å¯ä»¥å·¥ä½œï¼Œä½†ä»æœ‰ä»¥ä¸‹é—®é¢˜éœ€è¦ä¿®å¤ï¼š

---

## ğŸ”§ **åç«¯å¿…é¡»ä¿®æ”¹çš„é€»è¾‘**

### **é—®é¢˜ 1ï¼šWorker ä¸­çš„åœ°å€å‘ç°é€»è¾‘æ‰§è¡Œæ—¶æœºé”™è¯¯** âš ï¸

**æ–‡ä»¶ä½ç½®**ï¼š`backend/src/workers/travelProcessor.ts`ï¼ˆç¬¬156-187è¡Œï¼‰

**ç°æœ‰é€»è¾‘**ï¼š
```typescript
// âŒ é—®é¢˜ï¼šè¿™æ®µä»£ç åœ¨åˆçº¦è°ƒç”¨ä¹‹åæ‰æ‰§è¡Œ
if (isRandom && (targetWallet.toLowerCase() === '0x0000000000000000000000000000000000000000')) {
    const discoveredAddress = await explorationService.getRandomTargetAddress(chainKey);
    targetWallet = discoveredAddress;
    
    // æ›´æ–°æ•°æ®åº“
    await prisma.travel.update({
        where: { id: travelId },
        data: { targetAddress: discoveredAddress }
    });
}

// ç„¶åæ‰æ‰§è¡Œè§‚å¯Ÿ
const observation = await observerService.observeWallet(targetWallet, chainId);
```

**é—®é¢˜åˆ†æ**ï¼š
- âœ… åˆçº¦å·²ç»è®°å½•äº†é›¶åœ°å€
- âœ… Worker å‘ç°å®é™…åœ°å€å¹¶æ›´æ–°æ•°æ®åº“
- âœ… åŸºäºå®é™…åœ°å€è¿›è¡Œè§‚å¯Ÿå’Œç”Ÿæˆæ—¥è®°
- âš ï¸ **ä½†åˆçº¦ä¸­çš„ `activeTravels[tokenId].targetWallet` ä»ç„¶æ˜¯é›¶åœ°å€**
- âš ï¸ **è¿™ä¼šå¯¼è‡´é“¾ä¸Šè®°å½•å’Œæ•°æ®åº“è®°å½•ä¸ä¸€è‡´**

**ä¿®æ”¹æ–¹æ¡ˆ**ï¼š

```typescript
// backend/src/workers/travelProcessor.ts

async function processTravelJob(job: Job) {
    const { travelId } = job.data;
    
    const travel = await prisma.travel.findUnique({
        where: { id: travelId },
        include: { user: { include: { frog: true } } }
    });

    if (!travel) throw new Error('Travel not found');

    let targetWallet = travel.targetAddress;
    const isRandom = travel.isRandom;
    const chainKey = travel.targetChain.toLowerCase();

    try {
        // âœ… 1. å¦‚æœæ˜¯éšæœºæ¢ç´¢ä¸”æ˜¯é›¶åœ°å€ï¼Œå…ˆå‘ç°å®é™…åœ°å€
        if (isRandom && targetWallet.toLowerCase() === '0x0000000000000000000000000000000000000000') {
            console.log('ğŸ² Random exploration detected, discovering target address...');
            
            const explorationService = new ExplorationService();
            const discoveredAddress = await explorationService.getRandomTargetAddress(chainKey);
            
            if (!discoveredAddress || discoveredAddress === '0x0000000000000000000000000000000000000000') {
                throw new Error('Failed to discover random address');
            }
            
            console.log('âœ… Discovered address:', discoveredAddress);
            
            // âœ… 2. æ›´æ–°æ•°æ®åº“ä¸­çš„ç›®æ ‡åœ°å€
            await prisma.travel.update({
                where: { id: travelId },
                data: { 
                    targetAddress: discoveredAddress,
                    // å¯é€‰ï¼šè®°å½•å‘ç°æ—¶é—´
                    addressDiscoveredAt: new Date()
                }
            });
            
            targetWallet = discoveredAddress;
            
            // âœ… 3. å‘é€å‘ç°é€šçŸ¥
            await wsManager.sendToUser(travel.userId, {
                type: 'travel_update',
                payload: {
                    travelId: travel.id,
                    stage: 'DISCOVERING',
                    message: {
                        text: `å‘ç°ç›®æ ‡åœ°å€ï¼š${discoveredAddress.slice(0, 6)}...${discoveredAddress.slice(-4)}`,
                        type: 'DISCOVERY'
                    }
                }
            });
        }

        // âœ… 4. éªŒè¯åœ°å€æœ‰æ•ˆæ€§
        if (!ethers.utils.isAddress(targetWallet)) {
            throw new Error(`Invalid target address: ${targetWallet}`);
        }

        // âœ… 5. æ‰§è¡Œæ—…è¡Œæµç¨‹
        const travelExecutor = new TravelExecutor(
            prisma,
            aiService,
            chainService,
            souvenirService,
            wsManager
        );

        await travelExecutor.executeTravel(travelId);

    } catch (error) {
        console.error('Travel processing failed:', error);
        
        await prisma.travel.update({
            where: { id: travelId },
            data: { 
                status: 'FAILED',
                errorMessage: error.message 
            }
        });

        await wsManager.sendToUser(travel.userId, {
            type: 'travel_failed',
            payload: {
                travelId: travel.id,
                error: error.message
            }
        });

        throw error;
    }
}
```

---

### **é—®é¢˜ 2ï¼šæ¢ç´¢æœåŠ¡éœ€è¦å¢å¼ºé”™è¯¯å¤„ç†** âš ï¸

**æ–‡ä»¶ä½ç½®**ï¼š`backend/src/services/travel/exploration.service.ts`ï¼ˆç¬¬238è¡Œï¼‰

**éœ€è¦æ·»åŠ çš„é€»è¾‘**ï¼š

```typescript
// backend/src/services/travel/exploration.service.ts

export class ExplorationService {
    private readonly MAX_RETRY = 3;
    private readonly RETRY_DELAY = 2000;

    /**
     * è·å–éšæœºç›®æ ‡åœ°å€ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
     */
    async getRandomTargetAddress(chain: string): Promise<string> {
        for (let attempt = 1; attempt <= this.MAX_RETRY; attempt++) {
            try {
                console.log(`ğŸ² Attempt ${attempt}/${this.MAX_RETRY} to discover random address on ${chain}`);
                
                const address = await this.discoverLuckyAddress(chain);
                
                // âœ… éªŒè¯åœ°å€æœ‰æ•ˆæ€§
                if (!address || address === '0x0000000000000000000000000000000000000000') {
                    throw new Error('Discovered address is zero address');
                }
                
                if (!ethers.utils.isAddress(address)) {
                    throw new Error(`Invalid address format: ${address}`);
                }
                
                // âœ… éªŒè¯åœ°å€æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ´»åŠ¨
                const isValid = await this.validateAddress(address, chain);
                if (!isValid) {
                    console.log(`âš ï¸  Address ${address} validation failed, retrying...`);
                    continue;
                }
                
                console.log(`âœ… Valid address discovered: ${address}`);
                return address;
                
            } catch (error) {
                console.error(`âŒ Attempt ${attempt} failed:`, error.message);
                
                if (attempt === this.MAX_RETRY) {
                    // âœ… æœ€åä¸€æ¬¡å°è¯•å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨åœ°å€
                    console.log('âš ï¸  All attempts failed, using fallback address');
                    return await this.getFallbackAddress(chain);
                }
                
                // ç­‰å¾…åé‡è¯•
                await this.delay(this.RETRY_DELAY * attempt);
            }
        }
        
        throw new Error('Failed to discover random address after all retries');
    }

    /**
     * ä»é“¾ä¸Šå®æ—¶æŠ“å–æ´»è·ƒé’±åŒ…
     */
    async discoverLuckyAddress(chain: string): Promise<string> {
        const provider = this.getProvider(chain);
        
        // è·å–æœ€æ–°åŒºå—
        const latestBlock = await provider.getBlockNumber();
        
        // éšæœºé€‰æ‹©æœ€è¿‘çš„ä¸€ä¸ªåŒºå—ï¼ˆæœ€è¿‘100ä¸ªåŒºå—å†…ï¼‰
        const randomOffset = Math.floor(Math.random() * 100);
        const targetBlock = latestBlock - randomOffset;
        
        console.log(`ğŸ” Scanning block ${targetBlock} on ${chain}`);
        
        // è·å–åŒºå—æ•°æ®
        const block = await provider.getBlockWithTransactions(targetBlock);
        
        if (!block || !block.transactions || block.transactions.length === 0) {
            throw new Error(`No transactions in block ${targetBlock}`);
        }
        
        // æ”¶é›†æ‰€æœ‰å‘é€è€…åœ°å€ï¼ˆæ’é™¤åˆçº¦åˆ›å»ºäº¤æ˜“ï¼‰
        const senderAddresses = block.transactions
            .filter(tx => tx.to !== null) // æ’é™¤åˆçº¦åˆ›å»º
            .map(tx => tx.from)
            .filter((addr, index, self) => self.indexOf(addr) === index); // å»é‡
        
        if (senderAddresses.length === 0) {
            throw new Error('No valid sender addresses found');
        }
        
        // éšæœºé€‰æ‹©ä¸€ä¸ªåœ°å€
        const randomIndex = Math.floor(Math.random() * senderAddresses.length);
        const selectedAddress = senderAddresses[randomIndex];
        
        console.log(`ğŸ¯ Selected address from ${senderAddresses.length} candidates`);
        
        return selectedAddress;
    }

    /**
     * éªŒè¯åœ°å€æ˜¯å¦æœ‰æ•ˆï¼ˆæœ‰è¶³å¤Ÿçš„äº¤æ˜“å†å²ï¼‰
     */
    async validateAddress(address: string, chain: string): Promise<boolean> {
        try {
            const provider = this.getProvider(chain);
            
            // âœ… æ£€æŸ¥1ï¼šä¸æ˜¯åˆçº¦åœ°å€
            const code = await provider.getCode(address);
            if (code !== '0x') {
                console.log(`âš ï¸  ${address} is a contract, skipping`);
                return false;
            }
            
            // âœ… æ£€æŸ¥2ï¼šæœ‰ä½™é¢
            const balance = await provider.getBalance(address);
            if (balance.isZero()) {
                console.log(`âš ï¸  ${address} has zero balance, skipping`);
                return false;
            }
            
            // âœ… æ£€æŸ¥3ï¼šæœ‰äº¤æ˜“å†å²ï¼ˆé€šè¿‡ nonceï¼‰
            const nonce = await provider.getTransactionCount(address);
            if (nonce < 5) {
                console.log(`âš ï¸  ${address} has only ${nonce} transactions, skipping`);
                return false;
            }
            
            console.log(`âœ… ${address} validation passed (nonce: ${nonce})`);
            return true;
            
        } catch (error) {
            console.error(`Validation error for ${address}:`, error.message);
            return false;
        }
    }

    /**
     * è·å–å¤‡ç”¨åœ°å€ï¼ˆé¢„è®¾çš„çŸ¥ååœ°å€ï¼‰
     */
    async getFallbackAddress(chain: string): Promise<string> {
        // âœ… ä¸ºæ¯æ¡é“¾é¢„è®¾ä¸€äº›çŸ¥ååœ°å€ä½œä¸ºå¤‡ç”¨
        const fallbackAddresses: Record<string, string[]> = {
            ethereum: [
                '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', // Vitalik
                '0x28C6c06298d514Db089934071355E5743bf21d60', // Binance 14
                '0x21a31Ee1afC51d94C2eFcCAa2092aD1028285549', // Binance 15
            ],
            arbitrum: [
                '0x1234567890123456789012345678901234567890', // æ›¿æ¢ä¸ºå®é™…åœ°å€
            ],
            zetachain: [
                '0x1234567890123456789012345678901234567890', // æ›¿æ¢ä¸ºå®é™…åœ°å€
            ],
        };
        
        const addresses = fallbackAddresses[chain.toLowerCase()] || fallbackAddresses.ethereum;
        const randomIndex = Math.floor(Math.random() * addresses.length);
        
        console.log(`âš ï¸  Using fallback address for ${chain}`);
        return addresses[randomIndex];
    }

    private getProvider(chain: string): ethers.providers.Provider {
        // å®ç° provider è·å–é€»è¾‘
        const rpcUrls: Record<string, string> = {
            ethereum: process.env.ETHEREUM_RPC || 'https://eth.public-rpc.com',
            arbitrum: process.env.ARBITRUM_RPC || 'https://arb1.arbitrum.io/rpc',
            zetachain: process.env.ZETACHAIN_RPC || 'https://zetachain-athens.blockpi.network/v1/rpc/public',
        };
        
        const rpcUrl = rpcUrls[chain.toLowerCase()];
        if (!rpcUrl) {
            throw new Error(`Unsupported chain: ${chain}`);
        }
        
        return new ethers.providers.JsonRpcProvider(rpcUrl);
    }

    private delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
```

---

### **é—®é¢˜ 3ï¼šæ•°æ®åº“ Schema éœ€è¦æ·»åŠ å­—æ®µ** ğŸ“

**æ–‡ä»¶ä½ç½®**ï¼š`backend/prisma/schema.prisma`

```prisma
model Travel {
  id                String              @id @default(cuid())
  userId            String
  frogId            String
  
  // ç›®æ ‡ä¿¡æ¯
  targetChain       ChainType
  targetAddress     String              // âœ… å¯ä»¥æ˜¯é›¶åœ°å€
  targetENS         String?
  isRandom          Boolean             @default(false)
  
  // âœ… æ–°å¢ï¼šåœ°å€å‘ç°æ—¶é—´ï¼ˆç”¨äºéšæœºæ¢ç´¢ï¼‰
  addressDiscoveredAt DateTime?
  
  // âœ… æ–°å¢ï¼šåŸå§‹ç›®æ ‡åœ°å€ï¼ˆä¿ç•™é›¶åœ°å€è®°å½•ï¼‰
  originalTargetAddress String?
  
  // æ—…è¡ŒçŠ¶æ€
  status            TravelStatus        @default(PENDING)
  currentStage      TravelStage         @default(PREPARING)
  progress          Int                 @default(0)
  
  // é”™è¯¯å¤„ç†
  errorMessage      String?
  
  // å…¶ä»–å­—æ®µ...
  duration          Int
  startedAt         DateTime            @default(now())
  completedAt       DateTime?
  
  // å…³è”
  user              User                @relation(fields: [userId], references: [id])
  frog              Frog                @relation(fields: [frogId], references: [id])
  postcard          Postcard?
  
  @@index([userId])
  @@index([frogId])
  @@index([status])
}
```

**è¿è¡Œè¿ç§»**ï¼š

```bash
cd backend
npx prisma migrate dev --name add_address_discovery_fields
npx prisma generate
```

---

## ğŸ¨ **å‰ç«¯éœ€è¦ä¿®æ”¹çš„é€»è¾‘**

### **é—®é¢˜ 4ï¼šå‰ç«¯éœ€è¦å¤„ç†åœ°å€å‘ç°çŠ¶æ€** âš ï¸

**æ–‡ä»¶ä½ç½®**ï¼š`frontend/src/components/travel/TravelStatus.tsx`

**æ–°å¢é€»è¾‘**ï¼š

```typescript
// frontend/src/components/travel/TravelStatus.tsx

import { useEffect, useState } from 'react';
import { useWebSocket } from '@/hooks/useWebSocket';

interface TravelStatusProps {
    travelId: string;
}

export function TravelStatus({ travelId }: TravelStatusProps) {
    const [stage, setStage] = useState<string>('PREPARING');
    const [progress, setProgress] = useState(0);
    const [message, setMessage] = useState('');
    const [targetAddress, setTargetAddress] = useState<string>('');
    const [isDiscovering, setIsDiscovering] = useState(false);

    const { socket } = useWebSocket();

    useEffect(() => {
        if (!socket) return;

        // âœ… ç›‘å¬æ—…è¡Œæ›´æ–°
        socket.on('travel_update', (data) => {
            if (data.payload.travelId !== travelId) return;

            setStage(data.payload.stage);
            setProgress(data.payload.progress || 0);
            setMessage(data.payload.message?.text || '');

            // âœ… å¤„ç†åœ°å€å‘ç°é˜¶æ®µ
            if (data.payload.stage === 'DISCOVERING') {
                setIsDiscovering(true);
                
                // ä»æ¶ˆæ¯ä¸­æå–åœ°å€
                const addressMatch = data.payload.message?.text.match(/0x[a-fA-F0-9]{40}/);
                if (addressMatch) {
                    setTargetAddress(addressMatch[0]);
                    setIsDiscovering(false);
                }
            }
        });

        return () => {
            socket.off('travel_update');
        };
    }, [socket, travelId]);

    return (
        <div className="travel-status">
            <div className="progress-bar">
                <div 
                    className="progress-fill" 
                    style={{ width: `${progress}%` }}
                />
            </div>

            <div className="stage-info">
                <h3>{getStageText(stage)}</h3>
                <p>{message}</p>
            </div>

            {/* âœ… æ˜¾ç¤ºåœ°å€å‘ç°çŠ¶æ€ */}
            {isDiscovering && (
                <div className="discovering-animation">
                    <span className="loading-spinner"></span>
                    <p>ğŸ² æ­£åœ¨å‘ç°ç›®æ ‡åœ°å€...</p>
                </div>
            )}

            {/* âœ… æ˜¾ç¤ºå‘ç°çš„åœ°å€ */}
            {targetAddress && (
                <div className="target-address">
                    <label>ç›®æ ‡åœ°å€ï¼š</label>
                    <a 
                        href={`https://etherscan.io/address/${targetAddress}`}
                        target="_blank"
                        rel="noopener noreferrer"
                    >
                        {targetAddress.slice(0, 6)}...{targetAddress.slice(-4)}
                    </a>
                </div>
            )}

            <div className="progress-text">{progress}%</div>
        </div>
    );
}

function getStageText(stage: string): string {
    const stageMap: Record<string, string> = {
        PREPARING: 'å‡†å¤‡å‡ºå‘',
        DEPARTING: 'ç¦»å¼€å®¶é—¨',
        CROSSING: 'è·¨é“¾ç©¿è¶Š',
        ARRIVING: 'åˆ°è¾¾ç›®çš„åœ°',
        DISCOVERING: 'ğŸ² å‘ç°ç›®æ ‡',  // âœ… æ–°å¢é˜¶æ®µ
        EXPLORING: 'æ¢ç´¢è§‚å¯Ÿ',
        RETURNING: 'è¿”ç¨‹å›å®¶',
    };
    return stageMap[stage] || stage;
}
```

---

### **é—®é¢˜ 5ï¼šå‰ç«¯ API è°ƒç”¨éœ€è¦å¤„ç†é›¶åœ°å€** âš ï¸

**æ–‡ä»¶ä½ç½®**ï¼š`frontend/src/services/travel.service.ts`

```typescript
// frontend/src/services/travel.service.ts

export class TravelService {
    /**
     * å¼€å§‹éšæœºæ¢ç´¢
     */
    async startRandomTravel(
        frogId: string,
        targetChain: string,
        duration: number
    ): Promise<{ travelId: string; txHash: string }> {
        try {
            const response = await fetch(`${API_URL}/api/travel/start`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${getAuthToken()}`
                },
                body: JSON.stringify({
                    frogId,
                    travelType: 'RANDOM',
                    targetChain,
                    // âœ… ä¸ä¼  targetAddressï¼Œåç«¯ä¼šä½¿ç”¨é›¶åœ°å€
                    duration,
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || 'Failed to start travel');
            }

            const data = await response.json();
            return data.data;

        } catch (error: any) {
            console.error('Failed to start random travel:', error);
            
            // âœ… ç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯
            if (error.message.includes('Invalid target')) {
                throw new Error('åˆçº¦ä¸æ”¯æŒéšæœºæ¢ç´¢ï¼Œè¯·è”ç³»ç®¡ç†å‘˜æ›´æ–°åˆçº¦');
            }
            
            throw error;
        }
    }

    /**
     * å¼€å§‹æŒ‡å®šåœ°å€æ—…è¡Œ
     */
    async startTargetedTravel(
        frogId: string,
        targetChain: string,
        targetAddress: string,
        duration: number
    ): Promise<{ travelId: string; txHash: string }> {
        // âœ… éªŒè¯åœ°å€æ ¼å¼
        if (!targetAddress || !ethers.utils.isAddress(targetAddress)) {
            throw new Error('Invalid target address format');
        }

        const response = await fetch(`${API_URL}/api/travel/start`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${getAuthToken()}`
            },
            body: JSON.stringify({
                frogId,
                travelType: 'TARGETED',
                targetChain,
                targetAddress, // âœ… æ˜ç¡®æŒ‡å®šåœ°å€
                duration,
            })
        });

        if (!response.ok) {
            throw new Error('Failed to start travel');
        }

        const data = await response.json();
        return data.data;
    }
}
```

---

### **é—®é¢˜ 6ï¼šå‰ç«¯éœ€è¦æ˜¾ç¤ºéšæœºæ¢ç´¢ç‰¹æ®Š UI** ğŸ¨

**æ–‡ä»¶ä½ç½®**ï¼š`frontend/src/pages/Desktop.tsx`

```typescript
// frontend/src/pages/Desktop.tsx

export function Desktop() {
    const [travelType, setTravelType] = useState<'RANDOM' | 'TARGETED'>('RANDOM');
    const [showAddressInput, setShowAddressInput] = useState(false);

    return (
        <div className="desktop-page">
            <div className="travel-controls">
                {/* âœ… æ—…è¡Œç±»å‹é€‰æ‹© */}
                <div className="travel-type-selector">
                    <button 
                        className={travelType === 'RANDOM' ? 'active' : ''}
                        onClick={() => {
                            setTravelType('RANDOM');
                            setShowAddressInput(false);
                        }}
                    >
                        ğŸ² éšæœºæ¢ç´¢
                    </button>
                    <button 
                        className={travelType === 'TARGETED' ? 'active' : ''}
                        onClick={() => {
                            setTravelType('TARGETED');
                            setShowAddressInput(true);
                        }}
                    >
                        ğŸ¯ æŒ‡å®šåœ°å€
                    </button>
                </div>

                {/* âœ… ä»…åœ¨æŒ‡å®šåœ°å€æ¨¡å¼ä¸‹æ˜¾ç¤ºè¾“å…¥æ¡† */}
                {showAddressInput && (
                    <input
                        type="text"
                        placeholder="è¾“å…¥ç›®æ ‡é’±åŒ…åœ°å€æˆ– ENS"
                        className="address-input"
                    />
                )}

                {/* âœ… éšæœºæ¢ç´¢è¯´æ˜ */}
                {travelType === 'RANDOM' && (
                    <div className="random-travel-info">
                        <p>ğŸ² é’è›™ä¼šéšæœºé€‰æ‹©ä¸€ä¸ªæ´»è·ƒçš„é’±åŒ…åœ°å€è¿›è¡Œè§‚å¯Ÿ</p>
                        <p>âœ¨ æ¯æ¬¡æ¢ç´¢éƒ½æ˜¯ç‹¬ç‰¹çš„å†’é™©ï¼</p>
                    </div>
                )}

                <button onClick={handleStartTravel}>
                    {travelType === 'RANDOM' ? 'ğŸ² éšæœºå‡ºå‘' : 'ğŸ¯ å‡ºå‘'}
                </button>
            </div>
        </div>
    );
}
```

---

## ğŸ“‹ **å®Œæ•´ä¿®æ”¹æ¸…å•**

### **åç«¯ä¿®æ”¹** âœ…

1. **å¿…é¡»ä¿®æ”¹**ï¼š
   - âœ… `backend/src/workers/travelProcessor.ts` - åœ°å€å‘ç°é€»è¾‘å‰ç½®
   - âœ… `backend/src/services/travel/exploration.service.ts` - å¢å¼ºé”™è¯¯å¤„ç†å’Œé‡è¯•
   - âœ… `backend/prisma/schema.prisma` - æ·»åŠ åœ°å€å‘ç°å­—æ®µ

2. **å»ºè®®ä¿®æ”¹**ï¼š
   - ğŸ”„ `backend/src/api/routes/travel.routes.ts` - æ·»åŠ æ›´è¯¦ç»†çš„é”™è¯¯å¤„ç†
   - ğŸ”„ `backend/src/services/travel/travel.executor.ts` - æ·»åŠ åœ°å€éªŒè¯é€»è¾‘

### **å‰ç«¯ä¿®æ”¹** âœ…

1. **å¿…é¡»ä¿®æ”¹**ï¼š
   - âœ… `frontend/src/components/travel/TravelStatus.tsx` - å¤„ç†åœ°å€å‘ç°çŠ¶æ€
   - âœ… `frontend/src/services/travel.service.ts` - åŒºåˆ†éšæœºå’ŒæŒ‡å®šæ—…è¡Œ

2. **å»ºè®®ä¿®æ”¹**ï¼š
   - ğŸ”„ `frontend/src/pages/Desktop.tsx` - ä¼˜åŒ– UI æ˜¾ç¤º
   - ğŸ”„ æ·»åŠ åœ°å€å‘ç°åŠ¨ç”»æ•ˆæœ

### **æ•°æ®åº“ä¿®æ”¹** âœ…

```bash
cd backend
npx prisma migrate dev --name add_address_discovery_fields
```

---

## ğŸ¯ **æ€»ç»“**

**å‰åç«¯ä¿®æ”¹è¦ç‚¹**ï¼š

1. âœ… **åˆçº¦**ï¼šåˆ é™¤é›¶åœ°å€éªŒè¯ï¼ˆå·²åœ¨å‰é¢æä¾›ï¼‰
2. âœ… **åç«¯**ï¼šåœ¨ Worker ä¸­å®ç°åœ°å€å‘ç°å’ŒéªŒè¯é€»è¾‘
3. âœ… **å‰ç«¯**ï¼šå¤„ç†åœ°å€å‘ç°çŠ¶æ€å’Œ UI åé¦ˆ
4. âœ… **æ•°æ®åº“**ï¼šæ·»åŠ åœ°å€å‘ç°ç›¸å…³å­—æ®µ

æ‰€æœ‰è¿™äº›ä¿®æ”¹éƒ½æ˜¯ä¸ºäº†ç¡®ä¿éšæœºæ¢ç´¢åŠŸèƒ½çš„**å®‰å…¨æ€§ã€å¯é æ€§å’Œç”¨æˆ·ä½“éªŒ**ï¼