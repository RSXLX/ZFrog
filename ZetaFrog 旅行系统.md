
# ğŸ¸ ZetaFrog æ—…è¡Œç³»ç»Ÿå‡çº§ â€” P0 ç‰ˆæœ¬è¯¦ç»†éœ€æ±‚

## ğŸ“‹ æ ¸å¿ƒç†å¿µ

### ä»ã€ŒæŒ‡å®šç©¿è¶Šã€å›å½’ã€Œéšæœºæ—…è¡Œã€

| æ—§è®¾è®¡é—®é¢˜ | æ–°è®¾è®¡ç†å¿µ |
|-----------|-----------|
| ç”¨æˆ·æŒ‡å®šåŒºå—/æ—¥æœŸ â†’ å¤ªåƒå·¥å…· | **é’è›™è‡ªå·±å†³å®šå»å“ª** â†’ ä¿ç•™æƒŠå–œ |
| æ—¶å…‰ç©¿è¶Š â†’ åå­—å¤ªç§‘å¹» | **æ—…è¡Œæ¢é™©** â†’ ç¬¦åˆã€Œæ—…è¡Œé’è›™ã€è°ƒæ€§ |
| å¿…é¡»é€‰æ‹© â†’ æ“ä½œå¤æ‚ | **ä¸€é”®å‡ºå‘** â†’ ç®€å•æœ‰è¶£ |

### æ–°çš„ç”¨æˆ·æ•…äº‹

```
ğŸ¸ æ—…è¡Œé’è›™çš„åŒºå—é“¾æ¢é™©

"ä½ çš„å°é’è›™èƒŒä¸Šå°ä¹¦åŒ…ï¼Œè·³è¿›äº†åŒºå—é“¾çš„ä¸–ç•Œï¼
 å®ƒå¯èƒ½ä¼šå» BSC çš„ç¹åå¸‚é›†ï¼Œ
 ä¹Ÿå¯èƒ½æºœè¾¾åˆ°ä»¥å¤ªåŠçš„å¤è€è¡—é“ï¼Œ
 æˆ–è€…è¹¦è·¶åˆ° ZetaChain çš„è·¨é“¾æ¡¥ä¸Š...
 
 ä½ æ°¸è¿œä¸çŸ¥é“å®ƒä¼šå¸¦å›ä»€ä¹ˆæ•…äº‹ï¼
 ä¹Ÿè®¸æ˜¯æŸä¸ªé’±åŒ…çš„æœ‰è¶£å…«å¦ï¼Œ
 ä¹Ÿè®¸æ˜¯æŸä¸ªå†å²æ—¶åˆ»çš„è§é—»ï¼Œ
 ä¹Ÿè®¸åªæ˜¯è·¯è¾¹æ¡åˆ°çš„ä¸€ç‰‡ç‰¹åˆ«çš„æ ‘å¶ğŸƒ
 
 ç»™å®ƒæ‰“åŒ…è¡Œæï¼Œè®©å®ƒå‡ºå‘å§ï¼"
```

---

## 1. P0 åŠŸèƒ½èŒƒå›´

### 1.1 æ ¸å¿ƒåŠŸèƒ½æ¸…å•

| åŠŸèƒ½ | P0 | P1 | è¯´æ˜ |
|------|:--:|:--:|------|
| ğŸ’ æ‰“åŒ…å‡ºå‘ | âœ… | | ä¸€é”®è®©é’è›™å‡ºå‘æ—…è¡Œ |
| ğŸ² éšæœºç›®çš„åœ° | âœ… | | é’è›™è‡ªå·±é€‰æ‹©å»å“ªæ¡é“¾ã€å“ªä¸ªåŒºå— |
| ğŸ“ æŒ‡å®šé’±åŒ…è§‚å¯Ÿ | âœ… | | å¯é€‰ï¼šæŒ‡å®šä¸€ä¸ªé’±åŒ…è®©é’è›™å»çœ‹çœ‹ |
| ğŸ“– æ—…è¡Œæ—¥è®° | âœ… | | AI ç”Ÿæˆçš„æ—…è¡Œè§é—» |
| ğŸ æ—…è¡Œçºªå¿µå“ | âœ… | | å¸¦å›çš„å°ç¤¼ç‰©ï¼ˆé“¾ä¸Šå‘ç°çš„æœ‰è¶£ä¿¡æ¯ï¼‰ |
| ğŸ† æ—…è¡Œå¾½ç«  | âœ… | | ç®€å•çš„æˆå°±ç³»ç»Ÿ |
| âš“ ç‰¹è‰²æ™¯ç‚¹ | | âœ… | é¢„è®¾çš„æœ‰è¶£åœ°ç‚¹ï¼ˆé˜¶æ®µäºŒï¼‰ |
| ğŸ—ºï¸ æ—…è¡Œåœ°å›¾ | | âœ… | å¯è§†åŒ–å»è¿‡çš„åœ°æ–¹ï¼ˆé˜¶æ®µäºŒï¼‰ |

### 1.2 æ—…è¡Œæµç¨‹

```
ã€å‡ºå‘å‰ã€‘
ç”¨æˆ·é€‰æ‹©ï¼š
â”œâ”€â”€ ğŸ² éšæœºæ—…è¡Œï¼ˆæ¨èï¼‰- é’è›™è‡ªå·±å†³å®šå»å“ª
â”‚      â””â”€â”€ å¯é€‰ï¼šæŒ‡å®šä¸€ä¸ªæƒ³è®©å®ƒè§‚å¯Ÿçš„é’±åŒ…åœ°å€
â”‚
â””â”€â”€ ğŸ“ å®šç‚¹æ—…è¡Œ - æŒ‡å®šå»å“ªæ¡é“¾
       â””â”€â”€ å¯é€‰ï¼šæŒ‡å®šé’±åŒ…åœ°å€

ã€æ—…è¡Œä¸­ã€‘
é’è›™å‡ºå‘ â†’ éšæœºé€‰æ‹©é“¾ â†’ éšæœºé€‰æ‹©æ—¶é—´ç‚¹ â†’ è§‚å¯Ÿé’±åŒ…æ´»åŠ¨ â†’ ç”Ÿæˆæ—¥è®° â†’ å¸¦å›çºªå¿µå“

ã€æ—…è¡Œç»“æŸã€‘
ç”¨æˆ·æ”¶åˆ°ï¼š
â”œâ”€â”€ ğŸ“– æ—…è¡Œæ—¥è®°ï¼ˆé’è›™è§†è§’çš„è§é—»ï¼‰
â”œâ”€â”€ ğŸ“¸ æ—…è¡Œå¿«ç…§ï¼ˆé‚£ä¸ªæ—¶åˆ»çš„é’±åŒ…çŠ¶æ€ï¼‰
â”œâ”€â”€ ğŸ çºªå¿µå“ï¼ˆç‰¹æ®Šå‘ç°ï¼‰
â””â”€â”€ ğŸ† å¾½ç« ï¼ˆå¦‚æœæ»¡è¶³æ¡ä»¶ï¼‰
```

---

## 2. æ•°æ®åº“å‡çº§è®¾è®¡

### 2.1 åŸºäºç°æœ‰ç»“æ„çš„æœ€å°æ”¹åŠ¨åŸåˆ™

ç°æœ‰ Travel è¡¨ç»“æ„ï¼š
```prisma
model Travel {
  id              String        @id @default(cuid())
  userId          String
  travelType      TravelType    // RANDOM / SPECIFIC / CELEBRITY
  targetChain     ChainType
  targetAddress   String?
  status          TravelStatus
  currentStage    TravelStage
  progress        Int
  startedAt       DateTime?
  completedAt     DateTime?
  estimatedDuration Int
  addressAnalysis Json?
  // ... å…¶ä»–å­—æ®µ
}
```

**å‡çº§ç­–ç•¥ï¼šæ‰©å±•è€Œéé‡å»º**

### 2.2 æ‰©å±• Travel è¡¨

```prisma
model Travel {
  // ========== ç°æœ‰å­—æ®µï¼ˆä¿æŒä¸å˜ï¼‰==========
  id              String        @id @default(cuid())
  userId          String
  user            User          @relation(fields: [userId], references: [id])
  
  travelType      TravelType
  targetChain     ChainType
  targetAddress   String?
  targetENS       String?
  
  status          TravelStatus  @default(PENDING)
  currentStage    TravelStage   @default(DEPARTING)
  progress        Int           @default(0)
  
  startedAt       DateTime?
  completedAt     DateTime?
  estimatedDuration Int
  
  addressAnalysis Json?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  statusMessages  TravelStatusMessage[]
  postcard        Postcard?
  
  // ========== P0 æ–°å¢å­—æ®µ ==========
  
  // æ—…è¡Œæ¢ç´¢è¯¦æƒ…
  exploredBlock     BigInt?               // æ¢ç´¢çš„åŒºå—å·
  exploredTimestamp DateTime?             // æ¢ç´¢çš„æ—¶é—´ç‚¹
  exploredSnapshot  Json?                 // é‚£ä¸ªæ—¶åˆ»çš„å¿«ç…§æ•°æ®
  /*
    exploredSnapshot ç»“æ„:
    {
      nativeBalance: "1.234",
      nativeSymbol: "BNB",
      txCount: 42,
      walletAge: "180å¤©",
      discoveries: [
        { type: "balance", desc: "æŒæœ‰ 1.23 BNB" },
        { type: "activity", desc: "æ˜¯ä¸ªæ´»è·ƒçš„äº¤æ˜“è€…" },
        { type: "fun_fact", desc: "è¿™ä¸ªé’±åŒ…åœ¨ç‰›å¸‚é¡¶å³°æ—¶..." }
      ]
    }
  */
  
  // æ—…è¡Œæ—¥è®°ï¼ˆAIç”Ÿæˆï¼‰
  diary             String?     @db.Text  // æ—…è¡Œæ—¥è®°
  diaryMood         DiaryMood?            // æ—¥è®°å¿ƒæƒ…
  
  // çºªå¿µå“
  souvenir          Json?                 // å¸¦å›çš„çºªå¿µå“
  /*
    souvenir ç»“æ„:
    {
      type: "postcard" | "leaf" | "stone" | "photo" | "story",
      name: "ä¸€å¼ æ—§æ˜ä¿¡ç‰‡",
      description: "ä¸Šé¢å†™ç€2021å¹´çš„ç¥ç¦...",
      rarity: 1-5,
      chainOrigin: "BSC_TESTNET",
      blockOrigin: "5000000"
    }
  */
  
  @@index([userId])
  @@index([status])
  @@index([exploredBlock])
}

// æ–°å¢ï¼šæ—¥è®°å¿ƒæƒ…æšä¸¾
enum DiaryMood {
  HAPPY         // å¼€å¿ƒ
  CURIOUS       // å¥½å¥‡
  SURPRISED     // æƒŠè®¶
  PEACEFUL      // å¹³é™
  EXCITED       // å…´å¥‹
  SLEEPY        // å›°å›°çš„
}
```

### 2.3 æ›´æ–°é“¾ç±»å‹æšä¸¾ï¼ˆæµ‹è¯•ç½‘ï¼‰

```prisma
enum ChainType {
  // P0 æ”¯æŒçš„æµ‹è¯•ç½‘
  BSC_TESTNET         // BSC æµ‹è¯•ç½‘
  ETH_SEPOLIA         // ETH Sepolia æµ‹è¯•ç½‘
  ZETACHAIN_ATHENS    // ZetaChain Athens æµ‹è¯•ç½‘
  
  // ä¿ç•™æœªæ¥æ‰©å±•
  ETHEREUM
  ARBITRUM
  BASE
  // ...
}
```

### 2.4 æ–°å¢æ—…è¡Œå¾½ç« è¡¨

```prisma
// ========== æ—…è¡Œå¾½ç«  ==========

model TravelBadge {
  id              String    @id @default(cuid())
  
  code            String    @unique           // å¾½ç« ä»£ç 
  name            String                      // åç§°
  description     String                      // æè¿°
  icon            String                      // emoji å›¾æ ‡
  
  // è§£é”æ¡ä»¶
  unlockType      BadgeUnlockType
  unlockCondition Json
  
  rarity          Int       @default(1)       // ç¨€æœ‰åº¦ 1-5
  isHidden        Boolean   @default(false)   // éšè—æˆå°±
  
  createdAt       DateTime  @default(now())
  
  userBadges      UserBadge[]
}

model UserBadge {
  id            String    @id @default(cuid())
  
  userId        String
  user          User      @relation(fields: [userId], references: [id])
  
  badgeId       String
  badge         TravelBadge @relation(fields: [badgeId], references: [id])
  
  unlockedAt    DateTime  @default(now())
  unlockedByTravelId String?               // è§£é”æ—¶çš„æ—…è¡Œ
  
  @@unique([userId, badgeId])
  @@index([userId])
}

enum BadgeUnlockType {
  TRIP_COUNT        // æ—…è¡Œæ¬¡æ•°
  CHAIN_VISIT       // è®¿é—®ç‰¹å®šé“¾
  MULTI_CHAIN       // å¤šé“¾æ—…è¡Œ
  RARE_FIND         // ç¨€æœ‰å‘ç°
  SPECIAL           // ç‰¹æ®Šæ¡ä»¶
}
```

### 2.5 æ–°å¢ç”¨æˆ·æ—…è¡Œç»Ÿè®¡

```prisma
// ========== æ—…è¡Œç»Ÿè®¡ ==========

model UserTravelStats {
  id              String    @id @default(cuid())
  
  userId          String    @unique
  user            User      @relation(fields: [userId], references: [id])
  
  // æ€»è®¡
  totalTrips      Int       @default(0)
  
  // å„é“¾ç»Ÿè®¡
  bscTrips        Int       @default(0)
  ethTrips        Int       @default(0)
  zetaTrips       Int       @default(0)
  
  // æœ‰è¶£ç»Ÿè®¡
  totalDiscoveries Int      @default(0)      // æ€»å‘ç°æ•°
  rareFinds       Int       @default(0)      // ç¨€æœ‰å‘ç°æ•°
  
  // æœ€è¿œ/æœ€æ—©æ—…è¡Œ
  earliestBlockVisited BigInt?
  oldestDateVisited    DateTime?
  
  updatedAt       DateTime  @updatedAt
}
```

### 2.6 æ‰©å±• User è¡¨

```prisma
model User {
  // ... ç°æœ‰å­—æ®µä¿æŒä¸å˜ ...
  
  // P0 æ–°å¢
  travelStats     UserTravelStats?
  badges          UserBadge[]
}
```

---

## 3. åç«¯æœåŠ¡è®¾è®¡

### 3.1 ç›®å½•ç»“æ„ï¼ˆæœ€å°æ–°å¢ï¼‰

```
backend/src/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ travel/
â”‚   â”‚   â”œâ”€â”€ travel.service.ts          # ç°æœ‰ï¼Œéœ€æ‰©å±•
â”‚   â”‚   â”œâ”€â”€ travel.executor.ts         # ç°æœ‰ï¼Œéœ€æ‰©å±•
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ exploration.service.ts     # æ–°å¢ï¼šæ¢ç´¢é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ snapshot.service.ts        # æ–°å¢ï¼šå¿«ç…§æœåŠ¡
â”‚   â”‚   â””â”€â”€ souvenir.generator.ts      # æ–°å¢ï¼šçºªå¿µå“ç”Ÿæˆ
â”‚   â”‚
â”‚   â”œâ”€â”€ ai/
â”‚   â”‚   â”œâ”€â”€ diary.generator.ts         # ç°æœ‰ï¼Œéœ€æ‰©å±•
â”‚   â”‚   â””â”€â”€ prompts/
â”‚   â”‚       â””â”€â”€ travel-diary.prompt.ts # æ–°å¢ï¼šæ—…è¡Œæ—¥è®°æ¨¡æ¿
â”‚   â”‚
â”‚   â””â”€â”€ badge/
â”‚       â”œâ”€â”€ badge.service.ts           # æ–°å¢ï¼šå¾½ç« æœåŠ¡
â”‚       â””â”€â”€ badge.checker.ts           # æ–°å¢ï¼šæ¡ä»¶æ£€æŸ¥
â”‚
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ travel.routes.ts               # ç°æœ‰ï¼Œéœ€æ‰©å±•
â”‚   â””â”€â”€ badge.routes.ts                # æ–°å¢ï¼šå¾½ç« API
```

### 3.2 é“¾é…ç½®ï¼ˆæµ‹è¯•ç½‘ï¼‰

```typescript
// src/config/chains.ts

export const SUPPORTED_CHAINS = {
  BSC_TESTNET: {
    name: 'BSC æµ‹è¯•ç½‘',
    displayName: 'å¸å®‰æµ‹è¯•é“¾',
    chainId: 97,
    rpcUrl: process.env.BSC_TESTNET_RPC || 'https://data-seed-prebsc-1-s1.binance.org:8545',
    nativeSymbol: 'tBNB',
    explorerUrl: 'https://testnet.bscscan.com',
    genesisTimestamp: new Date('2020-08-31'),
    avgBlockTime: 3,
    // æ—…è¡Œç›¸å…³
    scenery: 'ç¹åçš„æµ‹è¯•å¸‚é›†',  // åœºæ™¯æè¿°
    vibe: 'çƒ­é—¹',               // æ°›å›´
  },
  ETH_SEPOLIA: {
    name: 'Sepolia æµ‹è¯•ç½‘',
    displayName: 'ä»¥å¤ªåŠæµ‹è¯•é“¾',
    chainId: 11155111,
    rpcUrl: process.env.ETH_SEPOLIA_RPC || 'https://rpc.sepolia.org',
    nativeSymbol: 'SepoliaETH',
    explorerUrl: 'https://sepolia.etherscan.io',
    genesisTimestamp: new Date('2022-06-20'),
    avgBlockTime: 12,
    scenery: 'å¤è€çš„ä»¥å¤ªåŠè¡—é“',
    vibe: 'æ€€æ—§',
  },
  ZETACHAIN_ATHENS: {
    name: 'ZetaChain Athens',
    displayName: 'ZetaChain æµ‹è¯•é“¾',
    chainId: 7001,
    rpcUrl: process.env.ZETA_ATHENS_RPC || 'https://zetachain-athens-evm.blockpi.network/v1/rpc/public',
    nativeSymbol: 'aZETA',
    explorerUrl: 'https://athens.explorer.zetachain.com',
    genesisTimestamp: new Date('2023-02-01'),
    avgBlockTime: 6,
    scenery: 'è¿æ¥å„ä¸ªä¸–ç•Œçš„å½©è™¹æ¡¥',
    vibe: 'æ–°å¥‡',
  },
} as const;

export type ChainKey = keyof typeof SUPPORTED_CHAINS;
export const CHAIN_KEYS = Object.keys(SUPPORTED_CHAINS) as ChainKey[];
```

### 3.3 æ¢ç´¢æœåŠ¡ï¼ˆæ ¸å¿ƒæ–°å¢ï¼‰

```typescript
// src/services/travel/exploration.service.ts

import { createPublicClient, http, formatEther } from 'viem';
import { bscTestnet, sepolia } from 'viem/chains';
import { SUPPORTED_CHAINS, ChainKey, CHAIN_KEYS } from '../../config/chains';
import { logger } from '../../utils/logger';

export interface ExplorationResult {
  chain: ChainKey;
  blockNumber: bigint;
  timestamp: Date;
  
  // é’±åŒ…å¿«ç…§
  snapshot: WalletSnapshot;
  
  // å‘ç°åˆ—è¡¨
  discoveries: Discovery[];
}

export interface WalletSnapshot {
  address: string;
  nativeBalance: string;
  nativeSymbol: string;
  txCount: number;
  isActive: boolean;
  walletAge: string;
}

export interface Discovery {
  type: 'balance' | 'activity' | 'timing' | 'fun_fact';
  title: string;
  description: string;
  rarity: number; // 1-5
}

class ExplorationService {
  private clients: Record<ChainKey, any>;

  constructor() {
    // åˆå§‹åŒ–å„é“¾å®¢æˆ·ç«¯
    this.clients = {
      BSC_TESTNET: createPublicClient({
        chain: bscTestnet,
        transport: http(SUPPORTED_CHAINS.BSC_TESTNET.rpcUrl),
      }),
      ETH_SEPOLIA: createPublicClient({
        chain: sepolia,
        transport: http(SUPPORTED_CHAINS.ETH_SEPOLIA.rpcUrl),
      }),
      ZETACHAIN_ATHENS: createPublicClient({
        chain: {
          id: 7001,
          name: 'ZetaChain Athens',
          nativeCurrency: { name: 'ZETA', symbol: 'aZETA', decimals: 18 },
          rpcUrls: { default: { http: [SUPPORTED_CHAINS.ZETACHAIN_ATHENS.rpcUrl] } },
        } as any,
        transport: http(SUPPORTED_CHAINS.ZETACHAIN_ATHENS.rpcUrl),
      }),
    };
  }

  /**
   * éšæœºé€‰æ‹©æ—…è¡Œç›®çš„åœ°
   */
  async pickRandomDestination(): Promise<{ chain: ChainKey; blockNumber: bigint }> {
    // éšæœºé€‰æ‹©ä¸€æ¡é“¾
    const chain = CHAIN_KEYS[Math.floor(Math.random() * CHAIN_KEYS.length)];
    
    // éšæœºé€‰æ‹©ä¸€ä¸ªå†å²åŒºå—
    const blockNumber = await this.pickRandomBlock(chain);
    
    logger.info(`Frog decided to visit ${chain} at block ${blockNumber}`);
    
    return { chain, blockNumber };
  }

  /**
   * éšæœºé€‰æ‹©ä¸€ä¸ªåŒºå—
   */
  async pickRandomBlock(chain: ChainKey): Promise<bigint> {
    const client = this.clients[chain];
    const config = SUPPORTED_CHAINS[chain];
    
    const latestBlock = await client.getBlockNumber();
    const safeLatest = latestBlock - BigInt(10); // é¿å…å¤ªæ–°çš„åŒºå—
    
    // éšæœºé€‰æ‹©ï¼ˆåå‘æ›´æœ‰è¶£çš„æ—¶é—´æ®µï¼‰
    const ranges = this.getInterestingRanges(chain, safeLatest);
    const selectedRange = ranges[Math.floor(Math.random() * ranges.length)];
    
    const rangeSize = selectedRange.end - selectedRange.start;
    const randomOffset = BigInt(Math.floor(Math.random() * Number(rangeSize)));
    
    return selectedRange.start + randomOffset;
  }

  /**
   * è·å–æœ‰è¶£çš„åŒºå—èŒƒå›´ï¼ˆå¢åŠ éšæœºæ€§çš„åŒæ—¶åå‘æœ‰è¶£æ—¶æœŸï¼‰
   */
  private getInterestingRanges(chain: ChainKey, latestBlock: bigint): { start: bigint; end: bigint }[] {
    // ç®€å•å®ç°ï¼šåˆ†æˆå‡ ä¸ªæ—¶æœŸï¼Œéƒ½æœ‰æœºä¼šè¢«é€‰ä¸­
    const ranges = [];
    const step = latestBlock / BigInt(5);
    
    for (let i = 0; i < 5; i++) {
      ranges.push({
        start: step * BigInt(i),
        end: step * BigInt(i + 1),
      });
    }
    
    return ranges;
  }

  /**
   * æ¢ç´¢æŒ‡å®šä½ç½®
   */
  async explore(
    chain: ChainKey,
    blockNumber: bigint,
    targetAddress: string
  ): Promise<ExplorationResult> {
    logger.info(`Exploring ${chain} block ${blockNumber} for wallet ${targetAddress}`);

    const client = this.clients[chain];
    const config = SUPPORTED_CHAINS[chain];

    // 1. è·å–åŒºå—ä¿¡æ¯
    const block = await client.getBlock({ blockNumber });
    const timestamp = new Date(Number(block.timestamp) * 1000);

    // 2. è·å–é’±åŒ…å¿«ç…§
    const snapshot = await this.getWalletSnapshot(
      client,
      targetAddress,
      blockNumber,
      config
    );

    // 3. ç”Ÿæˆå‘ç°
    const discoveries = this.generateDiscoveries(snapshot, timestamp, config);

    return {
      chain,
      blockNumber,
      timestamp,
      snapshot,
      discoveries,
    };
  }

  /**
   * è·å–é’±åŒ…å¿«ç…§
   */
  private async getWalletSnapshot(
    client: any,
    address: string,
    blockNumber: bigint,
    config: typeof SUPPORTED_CHAINS[ChainKey]
  ): Promise<WalletSnapshot> {
    try {
      // è·å–ä½™é¢
      const balance = await client.getBalance({
        address: address as `0x${string}`,
        blockNumber,
      });

      // è·å–äº¤æ˜“æ•°
      const txCount = await client.getTransactionCount({
        address: address as `0x${string}`,
        blockNumber,
      });

      // è®¡ç®—é’±åŒ…æ´»è·ƒåº¦
      const isActive = txCount > 0;

      // ä¼°ç®—é’±åŒ…å¹´é¾„
      const walletAge = this.estimateWalletAge(txCount, blockNumber, config);

      return {
        address,
        nativeBalance: formatEther(balance),
        nativeSymbol: config.nativeSymbol,
        txCount,
        isActive,
        walletAge,
      };
    } catch (error) {
      logger.warn(`Failed to get wallet snapshot: ${error}`);
      
      // è¿”å›é»˜è®¤å€¼
      return {
        address,
        nativeBalance: '0',
        nativeSymbol: config.nativeSymbol,
        txCount: 0,
        isActive: false,
        walletAge: 'æœªçŸ¥',
      };
    }
  }

  /**
   * ä¼°ç®—é’±åŒ…å¹´é¾„
   */
  private estimateWalletAge(
    txCount: number,
    blockNumber: bigint,
    config: typeof SUPPORTED_CHAINS[ChainKey]
  ): string {
    if (txCount === 0) return 'å¯èƒ½æ˜¯æ–°é’±åŒ…';
    if (txCount < 10) return 'æ–°æ‰‹é’±åŒ…';
    if (txCount < 50) return 'æœ‰ç‚¹ç»éªŒçš„é’±åŒ…';
    if (txCount < 200) return 'è€ç»ƒçš„é’±åŒ…';
    return 'èµ„æ·±è€é’±åŒ…';
  }

  /**
   * ç”Ÿæˆå‘ç°
   */
  private generateDiscoveries(
    snapshot: WalletSnapshot,
    timestamp: Date,
    config: typeof SUPPORTED_CHAINS[ChainKey]
  ): Discovery[] {
    const discoveries: Discovery[] = [];
    const balance = parseFloat(snapshot.nativeBalance);
    const year = timestamp.getFullYear();
    const month = timestamp.getMonth() + 1;

    // ä½™é¢ç›¸å…³å‘ç°
    if (balance === 0) {
      discoveries.push({
        type: 'balance',
        title: 'ç©ºç©ºçš„å£è¢‹',
        description: `è¿™ä¸ªé’±åŒ…å½“æ—¶æ˜¯ç©ºçš„ï¼Œä¹Ÿè®¸ä¸»äººè¿˜æ²¡å¼€å§‹å†’é™©å‘¢`,
        rarity: 1,
      });
    } else if (balance < 0.1) {
      discoveries.push({
        type: 'balance',
        title: 'å°å°çš„ç§¯è“„',
        description: `åªæœ‰ ${balance.toFixed(4)} ${config.nativeSymbol}ï¼Œæ˜¯ä¸ªèŠ‚ä¿­çš„å°é’±åŒ…`,
        rarity: 1,
      });
    } else if (balance > 10) {
      discoveries.push({
        type: 'balance',
        title: 'å‘ç°å¤§æˆ·ï¼',
        description: `å“‡ï¼æœ‰ ${balance.toFixed(2)} ${config.nativeSymbol}ï¼è¿™æ˜¯ä¸ªå¯Œæœ‰çš„é’±åŒ…`,
        rarity: 4,
      });
    } else if (balance > 100) {
      discoveries.push({
        type: 'balance',
        title: 'å·¨é²¸å‡ºæ²¡ï¼',
        description: `éš¾ä»¥ç½®ä¿¡ï¼${balance.toFixed(2)} ${config.nativeSymbol}ï¼è¿™æ˜¯ä¼ è¯´ä¸­çš„å·¨é²¸å—ï¼Ÿ`,
        rarity: 5,
      });
    } else {
      discoveries.push({
        type: 'balance',
        title: 'æ™®é€šçš„ç§¯è“„',
        description: `æŒæœ‰ ${balance.toFixed(4)} ${config.nativeSymbol}`,
        rarity: 2,
      });
    }

    // æ´»è·ƒåº¦å‘ç°
    if (snapshot.txCount === 0) {
      discoveries.push({
        type: 'activity',
        title: 'å®‰é™çš„è§’è½',
        description: 'è¿™ä¸ªé’±åŒ…è¿˜æ²¡å‘é€è¿‡ä»»ä½•äº¤æ˜“ï¼Œåƒæ˜¯åœ¨æ²‰ç¡',
        rarity: 2,
      });
    } else if (snapshot.txCount < 10) {
      discoveries.push({
        type: 'activity',
        title: 'åˆšèµ·æ­¥çš„æ—…äºº',
        description: `åªæœ‰ ${snapshot.txCount} ç¬”äº¤æ˜“ï¼Œæ˜¯ä¸ªåŒºå—é“¾æ–°äºº`,
        rarity: 1,
      });
    } else if (snapshot.txCount > 100) {
      discoveries.push({
        type: 'activity',
        title: 'æ´»è·ƒçš„è€æ‰‹',
        description: `å·²ç»æœ‰ ${snapshot.txCount} ç¬”äº¤æ˜“äº†ï¼è¿™æ˜¯ä¸ªç»éªŒä¸°å¯Œçš„é’±åŒ…`,
        rarity: 3,
      });
    }

    // æ—¶é—´ç›¸å…³å‘ç°
    if (year === 2021) {
      discoveries.push({
        type: 'timing',
        title: 'ç‰›å¸‚çš„æ°”æ¯',
        description: '2021å¹´ï¼ç©ºæ°”ä¸­å¼¥æ¼«ç€ç‰›å¸‚çš„å‘³é“ï¼Œåˆ°å¤„éƒ½æ˜¯å…´å¥‹çš„äº¤æ˜“è€…',
        rarity: 3,
      });
    } else if (year === 2022 && month >= 5) {
      discoveries.push({
        type: 'timing',
        title: 'ç†Šå¸‚çš„å¯’é£',
        description: '2022å¹´ä¸‹åŠå¹´...å¸‚åœºæœ‰ç‚¹å†·æ¸…ï¼Œä½†åšæŒçš„äººè¿˜åœ¨',
        rarity: 2,
      });
    } else if (year === 2023) {
      discoveries.push({
        type: 'timing',
        title: 'å¤è‹çš„æ›™å…‰',
        description: '2023å¹´ï¼Œè™½ç„¶åˆšç»å†ç†Šå¸‚ï¼Œä½†æ–°çš„å¸Œæœ›æ­£åœ¨èŒèŠ½',
        rarity: 2,
      });
    }

    // éšæœºè¶£å‘³å‘ç°ï¼ˆå°æ¦‚ç‡ï¼‰
    if (Math.random() < 0.2) {
      const funFacts = [
        { title: 'å¹¸è¿æ•°å­—', description: 'è¿™ä¸ªåŒºå—å·çœ‹èµ·æ¥å¾ˆå‰åˆ©å‘¢ï¼', rarity: 2 },
        { title: 'è·¯è¾¹çš„å°èŠ±', description: 'é’è›™åœ¨è·¯è¾¹å‘ç°äº†ä¸€æœµå°èŠ±', rarity: 1 },
        { title: 'ç¥ç§˜çš„è„šå°', description: 'åœ°ä¸Šæœ‰å¥‡æ€ªçš„è„šå°ï¼Œæ˜¯è°ç•™ä¸‹çš„å‘¢ï¼Ÿ', rarity: 3 },
        { title: 'é£˜è½çš„æ ‘å¶', description: 'ä¸€ç‰‡é‡‘è‰²çš„æ ‘å¶é£˜è½åœ¨é’è›™å¤´ä¸Š', rarity: 2 },
      ];
      const randomFact = funFacts[Math.floor(Math.random() * funFacts.length)];
      discoveries.push({
        type: 'fun_fact',
        ...randomFact,
      });
    }

    return discoveries;
  }

  /**
   * éšæœºç”Ÿæˆç›®æ ‡åœ°å€ï¼ˆå¦‚æœç”¨æˆ·æ²¡æŒ‡å®šï¼‰
   */
  async getRandomTargetAddress(chain: ChainKey): Promise<string> {
    // ç®€å•å®ç°ï¼šä½¿ç”¨ä¸€äº›çŸ¥åçš„æµ‹è¯•ç½‘åœ°å€æˆ–éšæœºç”Ÿæˆ
    const knownAddresses: Record<ChainKey, string[]> = {
      BSC_TESTNET: [
        '0x0000000000000000000000000000000000000000', // é›¶åœ°å€
        '0x000000000000000000000000000000000000dEaD', // é»‘æ´åœ°å€
      ],
      ETH_SEPOLIA: [
        '0x0000000000000000000000000000000000000000',
        '0x000000000000000000000000000000000000dEaD',
      ],
      ZETACHAIN_ATHENS: [
        '0x0000000000000000000000000000000000000000',
        '0x000000000000000000000000000000000000dEaD',
      ],
    };

    const addresses = knownAddresses[chain];
    return addresses[Math.floor(Math.random() * addresses.length)];
  }
}

export const explorationService = new ExplorationService();
```

### 3.4 çºªå¿µå“ç”Ÿæˆå™¨

```typescript
// src/services/travel/souvenir.generator.ts

import { ChainKey, SUPPORTED_CHAINS } from '../../config/chains';
import { Discovery } from './exploration.service';

export interface Souvenir {
  type: SouvenirType;
  name: string;
  description: string;
  rarity: number;
  chainOrigin: ChainKey;
  blockOrigin: string;
  emoji: string;
}

export type SouvenirType = 'postcard' | 'leaf' | 'stone' | 'photo' | 'story' | 'feather' | 'shell';

// çºªå¿µå“æ¨¡æ¿
const SOUVENIR_TEMPLATES: Record<SouvenirType, { names: string[]; descriptions: string[]; emoji: string }> = {
  postcard: {
    names: ['æ—§æ˜ä¿¡ç‰‡', 'è¤ªè‰²çš„æ˜ä¿¡ç‰‡', 'æ‰‹ç»˜æ˜ä¿¡ç‰‡', 'å¤å¤æ˜ä¿¡ç‰‡'],
    descriptions: [
      'ä¸Šé¢ç”»ç€ {chain} çš„é£æ™¯',
      'å†™ç€æ¥è‡ª {year} å¹´çš„ç¥ç¦',
      'å°ç€æ¨¡ç³Šçš„åŒºå—å· {block}',
      'èƒŒé¢æœ‰é’è›™çš„è¹„å°',
    ],
    emoji: 'ğŸ“®',
  },
  leaf: {
    names: ['é‡‘è‰²è½å¶', 'å¹¸è¿å››å¶è‰', 'é“¶æå¶', 'æ«å¶'],
    descriptions: [
      'ä» {chain} çš„å¤§æ ‘ä¸Šé£˜è½',
      'æ²¾ç€ {year} å¹´çš„éœ²æ°´',
      'å¶è„‰ä¸Šåˆ»ç€ç¥ç§˜çš„æ•°å­—',
      'æ®è¯´èƒ½å¸¦æ¥å¥½è¿',
    ],
    emoji: 'ğŸ‚',
  },
  stone: {
    names: ['å…‰æ»‘çš„çŸ³å¤´', 'å¥‡ç‰¹çš„å°çŸ³å­', 'é—ªäº®çš„é¹…åµçŸ³', 'é€æ˜çš„æ™¶çŸ³'],
    descriptions: [
      'åœ¨ {chain} çš„å°æºªé‡Œæ¡åˆ°çš„',
      'ä¸Šé¢æœ‰å¥‡æ€ªçš„çº¹è·¯',
      'æ‘¸èµ·æ¥æ¸©æ¸©çš„',
      'åœ¨æœˆå…‰ä¸‹ä¼šå‘å…‰',
    ],
    emoji: 'ğŸª¨',
  },
  photo: {
    names: ['æ¨¡ç³Šçš„ç…§ç‰‡', 'çè´µçš„ç•™å½±', 'å·æ‹çš„ç…§ç‰‡', 'åˆå½±'],
    descriptions: [
      'æ‹ä¸‹äº† {chain} çš„è¡—æ™¯',
      'è®°å½•äº† {year} å¹´çš„æŸä¸ªç¬é—´',
      'é’è›™åœ¨è§’è½é‡Œæ¯”äº†ä¸ª V',
      'æœ‰ç‚¹æ›å…‰è¿‡åº¦ä½†å¾ˆçè´µ',
    ],
    emoji: 'ğŸ“·',
  },
  story: {
    names: ['å¬æ¥çš„æ•…äº‹', 'ç¥ç§˜çš„ä¼ è¯´', 'è€é’±åŒ…çš„å›å¿†', 'åŒºå—é“¾è½¶äº‹'],
    descriptions: [
      'å…³äº {chain} çš„ä¼ è¯´',
      '{year} å¹´å‘ç”Ÿçš„è¶£äº‹',
      'ä¸€ä¸ªè€é’±åŒ…å‘Šè¯‰é’è›™çš„ç§˜å¯†',
      'å€¼å¾—è®°å½•ä¸‹æ¥çš„è§é—»',
    ],
    emoji: 'ğŸ“–',
  },
  feather: {
    names: ['å½©è‰²ç¾½æ¯›', 'è½»é£˜é£˜çš„ç¾½æ¯›', 'ç¥å¥‡çš„ç¾½æ¯›', 'é‡‘è‰²ç¾½æ¯›'],
    descriptions: [
      'ä¸çŸ¥é“æ˜¯ä»€ä¹ˆé¸Ÿç•™ä¸‹çš„',
      'åœ¨ {chain} çš„é£ä¸­é£˜æ¥',
      'æ®è¯´æ˜¯å¹¸è¿çš„è±¡å¾',
      'è½»å¾—åƒç©ºæ°”ä¸€æ ·',
    ],
    emoji: 'ğŸª¶',
  },
  shell: {
    names: ['æ¼‚äº®çš„è´å£³', 'èºæ—‹è´å£³', 'çç è´å£³', 'å°æµ·èº'],
    descriptions: [
      'èƒ½å¬åˆ°åŒºå—é“¾çš„å£°éŸ³',
      'ä» {chain} çš„æµ·è¾¹å¸¦å›',
      'é‡Œé¢ä½ç€å°å¯„å±…èŸ¹',
      'é—ªç€çç èˆ¬çš„å…‰æ³½',
    ],
    emoji: 'ğŸš',
  },
};

class SouvenirGenerator {
  /**
   * æ ¹æ®æ¢ç´¢ç»“æœç”Ÿæˆçºªå¿µå“
   */
  generate(
    chain: ChainKey,
    blockNumber: bigint,
    timestamp: Date,
    discoveries: Discovery[]
  ): Souvenir {
    // æ ¹æ®å‘ç°çš„ç¨€æœ‰åº¦å†³å®šçºªå¿µå“ç¨€æœ‰åº¦
    const maxRarity = Math.max(...discoveries.map(d => d.rarity), 1);
    const souvenirRarity = Math.min(5, Math.max(1, maxRarity + Math.floor(Math.random() * 2) - 1));

    // éšæœºé€‰æ‹©çºªå¿µå“ç±»å‹ï¼ˆç¨€æœ‰å‘ç°æ›´å¯èƒ½å¾—åˆ°å¥½çºªå¿µå“ï¼‰
    const types: SouvenirType[] = ['postcard', 'leaf', 'stone', 'photo', 'story', 'feather', 'shell'];
    const type = types[Math.floor(Math.random() * types.length)];

    const template = SOUVENIR_TEMPLATES[type];
    const config = SUPPORTED_CHAINS[chain];
    const year = timestamp.getFullYear();

    // éšæœºé€‰æ‹©åç§°å’Œæè¿°
    const name = template.names[Math.floor(Math.random() * template.names.length)];
    let description = template.descriptions[Math.floor(Math.random() * template.descriptions.length)];

    // æ›¿æ¢å ä½ç¬¦
    description = description
      .replace('{chain}', config.displayName)
      .replace('{year}', year.toString())
      .replace('{block}', blockNumber.toString());

    return {
      type,
      name,
      description,
      rarity: souvenirRarity,
      chainOrigin: chain,
      blockOrigin: blockNumber.toString(),
      emoji: template.emoji,
    };
  }
}

export const souvenirGenerator = new SouvenirGenerator();
```

### 3.5 æ—…è¡Œæ—¥è®° AI Prompt

```typescript
// src/services/ai/prompts/travel-diary.prompt.ts

import { WalletSnapshot, Discovery } from '../../travel/exploration.service';
import { ChainKey, SUPPORTED_CHAINS } from '../../../config/chains';
import { Souvenir } from '../../travel/souvenir.generator';

export interface TravelDiaryParams {
  frogName: string;
  chain: ChainKey;
  blockNumber: bigint;
  timestamp: Date;
  targetAddress: string;
  snapshot: WalletSnapshot;
  discoveries: Discovery[];
  souvenir: Souvenir;
}

export function buildTravelDiaryPrompt(params: TravelDiaryParams): string {
  const {
    frogName,
    chain,
    blockNumber,
    timestamp,
    snapshot,
    discoveries,
    souvenir,
  } = params;

  const config = SUPPORTED_CHAINS[chain];
  const dateStr = timestamp.toLocaleDateString('zh-CN', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });

  const discoveriesText = discoveries
    .map(d => `- ${d.title}: ${d.description}`)
    .join('\n');

  return `
ä½ æ˜¯ä¸€åªå¯çˆ±çš„æ—…è¡Œé’è›™ï¼Œåå«ã€Œ${frogName}ã€ğŸ¸

ä»Šå¤©ä½ èƒŒç€å°ä¹¦åŒ…ï¼Œè·³è¿›äº†åŒºå—é“¾çš„ä¸–ç•Œå»æ—…è¡Œï¼

ã€æ—…è¡Œç›®çš„åœ°ã€‘
- ğŸŒ å»äº†ï¼š${config.displayName}ï¼ˆ${config.scenery}ï¼‰
- ğŸ“ åˆ°è¾¾ï¼šåŒºå— #${blockNumber}
- ğŸ“… æ—¶é—´ï¼š${dateStr}
- ğŸ  æ‹œè®¿çš„é’±åŒ…ï¼š${snapshot.address.slice(0, 10)}...

ã€ä½ çœ‹åˆ°çš„æƒ…å†µã€‘
- ğŸ’° é’±åŒ…ä½™é¢ï¼š${snapshot.nativeBalance} ${snapshot.nativeSymbol}
- ğŸ“Š äº¤æ˜“è®°å½•ï¼š${snapshot.txCount} ç¬”
- ğŸ‘¤ é’±åŒ…çŠ¶æ€ï¼š${snapshot.walletAge}

ã€æ—…é€”ä¸­çš„å‘ç°ã€‘
${discoveriesText}

ã€å¸¦å›çš„çºªå¿µå“ã€‘
${souvenir.emoji} ${souvenir.name}ï¼š${souvenir.description}

---

è¯·ä»¥ç¬¬ä¸€äººç§°å†™ä¸€ç¯‡ 100-200 å­—çš„ã€æ—…è¡Œæ—¥è®°ã€‘ï¼Œè¦æ±‚ï¼š

1. ğŸ¸ ç”¨å¯çˆ±ã€å¤©çœŸã€æ…µæ‡’çš„é’è›™å£å»ï¼ˆåƒåŸç‰ˆæ—…è¡Œé’è›™çš„æ„Ÿè§‰ï¼‰
2. ğŸ’ æè¿°è¿™æ¬¡æ—…è¡Œçš„è§é—»ï¼Œä½†ä¸è¦å¤ªæŠ€æœ¯æ€§
3. ğŸŒˆ æŠŠåŒºå—é“¾çš„ä¸œè¥¿è½¬åŒ–æˆå¯çˆ±çš„æ¯”å–»
4. ğŸ æåˆ°å¸¦å›çš„çºªå¿µå“
5. ğŸ˜´ å¯ä»¥æœ‰ç‚¹å°å›°ã€å°é¥¿ã€å°å¼€å¿ƒä¹‹ç±»çš„æƒ…ç»ª
6. ğŸ“ ç®€çŸ­è‡ªç„¶ï¼Œä¸è¦å¤ªæ­£å¼

è¯·ä»¥ JSON æ ¼å¼è¾“å‡ºï¼š
{
  "title": "æ—¥è®°æ ‡é¢˜ï¼ˆç®€çŸ­å¯çˆ±ï¼Œ5-10ä¸ªå­—ï¼‰",
  "content": "æ—¥è®°æ­£æ–‡",
  "mood": "HAPPY/CURIOUS/SURPRISED/PEACEFUL/EXCITED/SLEEPY",
  "oneLiner": "ä¸€å¥è¯æ€»ç»“è¿™æ¬¡æ—…è¡Œï¼ˆç”¨äºåˆ†äº«ï¼‰"
}
`.trim();
}
```

### 3.6 æ‰©å±•æ—…è¡ŒæœåŠ¡

```typescript
// src/services/travel/travel.service.tsï¼ˆæ‰©å±•ç°æœ‰æœåŠ¡ï¼‰

import { PrismaClient, TravelStatus, TravelType, DiaryMood } from '@prisma/client';
import { explorationService, ExplorationResult } from './exploration.service';
import { souvenirGenerator } from './souvenir.generator';
import { aiService } from '../ai/ai.service';
import { badgeService } from '../badge/badge.service';
import { ChainKey, CHAIN_KEYS } from '../../config/chains';
import { logger } from '../../utils/logger';

const prisma = new PrismaClient();

export interface StartTravelParams {
  userId: string;
  
  // æ—…è¡Œæ–¹å¼
  travelType: 'RANDOM' | 'SPECIFIC';
  
  // å¯é€‰ï¼šæŒ‡å®šé“¾ï¼ˆä¸æŒ‡å®šåˆ™éšæœºï¼‰
  targetChain?: ChainKey;
  
  // å¯é€‰ï¼šæŒ‡å®šè§‚å¯Ÿçš„é’±åŒ…
  targetAddress?: string;
}

class TravelService {
  /**
   * å¼€å§‹æ—…è¡Œ
   */
  async startTravel(params: StartTravelParams): Promise<{ travelId: string; estimatedDuration: number }> {
    const { userId, travelType, targetChain, targetAddress } = params;

    logger.info(`Starting travel for user ${userId}, type: ${travelType}`);

    // 1. ç¡®å®šç›®çš„åœ°
    let chain: ChainKey;
    let blockNumber: bigint;

    if (travelType === 'RANDOM') {
      // å®Œå…¨éšæœº
      const destination = await explorationService.pickRandomDestination();
      chain = destination.chain;
      blockNumber = destination.blockNumber;
    } else {
      // æŒ‡å®šé“¾ï¼ŒéšæœºåŒºå—
      chain = targetChain || CHAIN_KEYS[Math.floor(Math.random() * CHAIN_KEYS.length)];
      blockNumber = await explorationService.pickRandomBlock(chain);
    }

    // 2. ç¡®å®šè§‚å¯Ÿç›®æ ‡
    const address = targetAddress || await explorationService.getRandomTargetAddress(chain);

    // 3. åˆ›å»ºæ—…è¡Œè®°å½•
    const travel = await prisma.travel.create({
      data: {
        userId,
        travelType: travelType as TravelType,
        targetChain: chain,
        targetAddress: address,
        status: 'PENDING',
        currentStage: 'DEPARTING',
        progress: 0,
        estimatedDuration: 120, // 2åˆ†é’Ÿ
      },
    });

    // 4. åŠ å…¥å¤„ç†é˜Ÿåˆ—
    await this.queueTravelJob(travel.id, chain, blockNumber, address);

    return {
      travelId: travel.id,
      estimatedDuration: 120,
    };
  }

  /**
   * å¤„ç†æ—…è¡Œï¼ˆWorker è°ƒç”¨ï¼‰
   */
  async processTravel(
    travelId: string,
    chain: ChainKey,
    blockNumber: bigint,
    targetAddress: string
  ): Promise<void> {
    logger.info(`Processing travel ${travelId}`);

    // è·å–æ—…è¡Œä¿¡æ¯
    const travel = await prisma.travel.findUnique({
      where: { id: travelId },
      include: { user: { include: { frog: true } } },
    });

    if (!travel) throw new Error('Travel not found');

    try {
      // 1. æ›´æ–°çŠ¶æ€ï¼šå‡ºå‘ä¸­
      await this.updateTravelProgress(travelId, 10, 'DEPARTING');

      // 2. æ›´æ–°çŠ¶æ€ï¼šæ¢ç´¢ä¸­
      await this.updateTravelProgress(travelId, 30, 'EXPLORING');

      // 3. æ‰§è¡Œæ¢ç´¢
      const exploration = await explorationService.explore(chain, blockNumber, targetAddress);

      await this.updateTravelProgress(travelId, 50, 'EXPLORING');

      // 4. ç”Ÿæˆçºªå¿µå“
      const souvenir = souvenirGenerator.generate(
        chain,
        blockNumber,
        exploration.timestamp,
        exploration.discoveries
      );

      await this.updateTravelProgress(travelId, 70, 'RETURNING');

      // 5. ç”Ÿæˆæ—…è¡Œæ—¥è®°
      const frogName = travel.user.frog?.name || 'ZetaFrog';
      const { diary, mood } = await aiService.generateTravelDiary({
        frogName,
        chain,
        blockNumber,
        timestamp: exploration.timestamp,
        targetAddress,
        snapshot: exploration.snapshot,
        discoveries: exploration.discoveries,
        souvenir,
      });

      await this.updateTravelProgress(travelId, 90, 'RETURNING');

      // 6. ä¿å­˜ç»“æœ
      await prisma.travel.update({
        where: { id: travelId },
        data: {
          status: 'COMPLETED',
          currentStage: 'RETURNING',
          progress: 100,
          completedAt: new Date(),
          exploredBlock: blockNumber,
          exploredTimestamp: exploration.timestamp,
          exploredSnapshot: {
            ...exploration.snapshot,
            discoveries: exploration.discoveries,
          },
          diary,
          diaryMood: mood as DiaryMood,
          souvenir: souvenir,
        },
      });

      // 7. æ›´æ–°ç”¨æˆ·ç»Ÿè®¡
      await this.updateUserStats(travel.userId, chain);

      // 8. æ£€æŸ¥å¾½ç« 
      await badgeService.checkAndUnlock(travel.userId, {
        chain,
        travelId,
        discoveries: exploration.discoveries,
      });

      logger.info(`Travel ${travelId} completed successfully`);

    } catch (error) {
      logger.error(`Travel ${travelId} failed: ${error}`);
      
      await prisma.travel.update({
        where: { id: travelId },
        data: { status: 'FAILED' },
      });
      
      throw error;
    }
  }

  /**
   * æ›´æ–°æ—…è¡Œè¿›åº¦
   */
  private async updateTravelProgress(
    travelId: string,
    progress: number,
    stage: string
  ): Promise<void> {
    await prisma.travel.update({
      where: { id: travelId },
      data: { progress, currentStage: stage as any },
    });
  }

  /**
   * æ›´æ–°ç”¨æˆ·ç»Ÿè®¡
   */
  private async updateUserStats(userId: string, chain: ChainKey): Promise<void> {
    const chainField = {
      BSC_TESTNET: 'bscTrips',
      ETH_SEPOLIA: 'ethTrips',
      ZETACHAIN_ATHENS: 'zetaTrips',
    }[chain] as 'bscTrips' | 'ethTrips' | 'zetaTrips';

    await prisma.userTravelStats.upsert({
      where: { userId },
      create: {
        userId,
        totalTrips: 1,
        [chainField]: 1,
      },
      update: {
        totalTrips: { increment: 1 },
        [chainField]: { increment: 1 },
      },
    });
  }

  /**
   * åŠ å…¥å¤„ç†é˜Ÿåˆ—
   */
  private async queueTravelJob(
    travelId: string,
    chain: ChainKey,
    blockNumber: bigint,
    targetAddress: string
  ): Promise<void> {
    const { travelQueue } = require('../../queues');
    await travelQueue.add('process', {
      travelId,
      chain,
      blockNumber: blockNumber.toString(),
      targetAddress,
    }, {
      delay: 500,
      attempts: 3,
    });
  }
}

export const travelService = new TravelService();
```

### 3.7 å¾½ç« æœåŠ¡

```typescript
// src/services/badge/badge.service.ts

import { PrismaClient } from '@prisma/client';
import { ChainKey } from '../../config/chains';
import { Discovery } from '../travel/exploration.service';
import { logger } from '../../utils/logger';

const prisma = new PrismaClient();

export interface BadgeCheckContext {
  chain: ChainKey;
  travelId: string;
  discoveries: Discovery[];
}

class BadgeService {
  /**
   * æ£€æŸ¥å¹¶è§£é”å¾½ç« 
   */
  async checkAndUnlock(userId: string, context: BadgeCheckContext): Promise<string[]> {
    const unlockedBadges: string[] = [];

    // è·å–ç”¨æˆ·ç»Ÿè®¡
    const stats = await prisma.userTravelStats.findUnique({
      where: { userId },
    });

    // è·å–ç”¨æˆ·å·²æœ‰å¾½ç« 
    const existingBadges = await prisma.userBadge.findMany({
      where: { userId },
      select: { badgeId: true },
    });
    const existingIds = new Set(existingBadges.map(b => b.badgeId));

    // è·å–æ‰€æœ‰å¾½ç« 
    const allBadges = await prisma.travelBadge.findMany();

    for (const badge of allBadges) {
      if (existingIds.has(badge.id)) continue;

      const shouldUnlock = await this.checkCondition(
        badge.unlockType,
        badge.unlockCondition as any,
        stats,
        context
      );

      if (shouldUnlock) {
        await prisma.userBadge.create({
          data: {
            userId,
            badgeId: badge.id,
            unlockedByTravelId: context.travelId,
          },
        });
        unlockedBadges.push(badge.code);
        logger.info(`Badge ${badge.code} unlocked for user ${userId}`);
      }
    }

    return unlockedBadges;
  }

  /**
   * æ£€æŸ¥è§£é”æ¡ä»¶
   */
  private async checkCondition(
    type: string,
    condition: any,
    stats: any,
    context: BadgeCheckContext
  ): Promise<boolean> {
    switch (type) {
      case 'TRIP_COUNT':
        return (stats?.totalTrips || 0) >= condition.threshold;

      case 'CHAIN_VISIT':
        const chainField = {
          BSC_TESTNET: 'bscTrips',
          ETH_SEPOLIA: 'ethTrips',
          ZETACHAIN_ATHENS: 'zetaTrips',
        }[condition.chain];
        return (stats?.[chainField] || 0) >= condition.threshold;

      case 'MULTI_CHAIN':
        const visitedChains = [
          stats?.bscTrips > 0,
          stats?.ethTrips > 0,
          stats?.zetaTrips > 0,
        ].filter(Boolean).length;
        return visitedChains >= condition.threshold;

      case 'RARE_FIND':
        const maxRarity = Math.max(...context.discoveries.map(d => d.rarity));
        return maxRarity >= condition.minRarity;

      default:
        return false;
    }
  }

  /**
   * è·å–ç”¨æˆ·å¾½ç« 
   */
  async getUserBadges(userId: string) {
    return prisma.userBadge.findMany({
      where: { userId },
      include: { badge: true },
      orderBy: { unlockedAt: 'desc' },
    });
  }

  /**
   * è·å–æ‰€æœ‰å¾½ç« ï¼ˆå«è§£é”çŠ¶æ€ï¼‰
   */
  async getAllBadgesWithStatus(userId: string) {
    const [allBadges, userBadges] = await Promise.all([
      prisma.travelBadge.findMany({ where: { isHidden: false } }),
      prisma.userBadge.findMany({ where: { userId } }),
    ]);

    const unlockedIds = new Set(userBadges.map(ub => ub.badgeId));

    return allBadges.map(badge => ({
      ...badge,
      unlocked: unlockedIds.has(badge.id),
      unlockedAt: userBadges.find(ub => ub.badgeId === badge.id)?.unlockedAt,
    }));
  }
}

export const badgeService = new BadgeService();
```

---

## 4. å¾½ç« ç§å­æ•°æ®

```typescript
// scripts/seed-badges.ts

const badges = [
  // ====== æ—…è¡Œæ¬¡æ•° ======
  {
    code: 'FIRST_TRIP',
    name: 'ç¬¬ä¸€æ¬¡å‡ºé—¨',
    description: 'å®Œæˆç¬¬ä¸€æ¬¡æ—…è¡Œ',
    icon: 'ğŸ’',
    unlockType: 'TRIP_COUNT',
    unlockCondition: { threshold: 1 },
    rarity: 1,
  },
  {
    code: 'FREQUENT_TRAVELER',
    name: 'å¸¸æ—…å®¢',
    description: 'å®Œæˆ 5 æ¬¡æ—…è¡Œ',
    icon: 'âœˆï¸',
    unlockType: 'TRIP_COUNT',
    unlockCondition: { threshold: 5 },
    rarity: 2,
  },
  {
    code: 'TRAVEL_ADDICT',
    name: 'æ—…è¡Œä¸Šç˜¾',
    description: 'å®Œæˆ 20 æ¬¡æ—…è¡Œ',
    icon: 'ğŸŒ',
    unlockType: 'TRIP_COUNT',
    unlockCondition: { threshold: 20 },
    rarity: 3,
  },
  {
    code: 'TRAVEL_MASTER',
    name: 'æ—…è¡Œå¤§å¸ˆ',
    description: 'å®Œæˆ 50 æ¬¡æ—…è¡Œ',
    icon: 'ğŸ†',
    unlockType: 'TRIP_COUNT',
    unlockCondition: { threshold: 50 },
    rarity: 4,
  },

  // ====== é“¾ä¸“å± ======
  {
    code: 'BSC_VISITOR',
    name: 'BSC æ¸¸å®¢',
    description: 'å» BSC æ—…è¡Œ 3 æ¬¡',
    icon: 'ğŸŸ¡',
    unlockType: 'CHAIN_VISIT',
    unlockCondition: { chain: 'BSC_TESTNET', threshold: 3 },
    rarity: 2,
  },
  {
    code: 'ETH_VISITOR',
    name: 'ä»¥å¤ªåŠæ¸¸å®¢',
    description: 'å»ä»¥å¤ªåŠæ—…è¡Œ 3 æ¬¡',
    icon: 'ğŸ’',
    unlockType: 'CHAIN_VISIT',
    unlockCondition: { chain: 'ETH_SEPOLIA', threshold: 3 },
    rarity: 2,
  },
  {
    code: 'ZETA_VISITOR',
    name: 'ZetaChain æ¸¸å®¢',
    description: 'å» ZetaChain æ—…è¡Œ 3 æ¬¡',
    icon: 'âš¡',
    unlockType: 'CHAIN_VISIT',
    unlockCondition: { chain: 'ZETACHAIN_ATHENS', threshold: 3 },
    rarity: 2,
  },

  // ====== å¤šé“¾ ======
  {
    code: 'CHAIN_HOPPER',
    name: 'é“¾é—´æ—…è¡Œè€…',
    description: 'å»è¿‡ 2 æ¡ä¸åŒçš„é“¾',
    icon: 'ğŸŒ‰',
    unlockType: 'MULTI_CHAIN',
    unlockCondition: { threshold: 2 },
    rarity: 2,
  },
  {
    code: 'OMNI_TRAVELER',
    name: 'å…¨é“¾æ—…è¡Œå®¶',
    description: 'å»è¿‡æ‰€æœ‰ 3 æ¡é“¾',
    icon: 'ğŸŒˆ',
    unlockType: 'MULTI_CHAIN',
    unlockCondition: { threshold: 3 },
    rarity: 3,
  },

  // ====== ç¨€æœ‰å‘ç° ======
  {
    code: 'LUCKY_FINDER',
    name: 'å¹¸è¿å„¿',
    description: 'å‘ç°ç¨€æœ‰åº¦ 4 æ˜Ÿä»¥ä¸Šçš„ä¸œè¥¿',
    icon: 'ğŸ€',
    unlockType: 'RARE_FIND',
    unlockCondition: { minRarity: 4 },
    rarity: 3,
  },
  {
    code: 'WHALE_WATCHER',
    name: 'è§‚é²¸è€…',
    description: 'å‘ç°ä¸€ä¸ªå·¨é²¸é’±åŒ…',
    icon: 'ğŸ‹',
    unlockType: 'RARE_FIND',
    unlockCondition: { minRarity: 5 },
    rarity: 4,
  },
];
```

---

## 5. API æ¥å£è®¾è®¡

### 5.1 æ—…è¡Œ APIï¼ˆæ‰©å±•ç°æœ‰ï¼‰

```typescript
// src/routes/travel.routes.tsï¼ˆæ‰©å±•ï¼‰

/**
 * å¼€å§‹æ—…è¡Œ
 * POST /api/travel/start
 */
app.post('/api/travel/start', {
  schema: {
    body: {
      type: 'object',
      properties: {
        travelType: { 
          type: 'string', 
          enum: ['RANDOM', 'SPECIFIC'],
          default: 'RANDOM'
        },
        targetChain: { 
          type: 'string', 
          enum: ['BSC_TESTNET', 'ETH_SEPOLIA', 'ZETACHAIN_ATHENS'] 
        },
        targetAddress: { 
          type: 'string', 
          pattern: '^0x[a-fA-F0-9]{40}$' 
        },
      },
    },
  },
}, async (request, reply) => {
  const userId = request.user.id;
  const { travelType, targetChain, targetAddress } = request.body as any;

  const result = await travelService.startTravel({
    userId,
    travelType: travelType || 'RANDOM',
    targetChain,
    targetAddress,
  });

  return {
    success: true,
    data: result,
    message: 'ğŸ¸ é’è›™èƒŒä¸Šå°ä¹¦åŒ…å‡ºå‘å•¦ï¼',
  };
});

/**
 * è·å–æ—…è¡Œç»“æœ
 * GET /api/travel/:id
 */
app.get('/api/travel/:id', async (request, reply) => {
  const { id } = request.params as { id: string };

  const travel = await prisma.travel.findUnique({
    where: { id },
  });

  if (!travel) {
    return reply.status(404).send({
      success: false,
      error: 'æ‰¾ä¸åˆ°è¿™æ¬¡æ—…è¡Œ',
    });
  }

  return {
    success: true,
    data: {
      status: travel.status,
      progress: travel.progress,
      stage: travel.currentStage,
      // æ—…è¡Œå®Œæˆåè¿”å›è¯¦æƒ…
      ...(travel.status === 'COMPLETED' && {
        chain: travel.targetChain,
        exploredBlock: travel.exploredBlock?.toString(),
        exploredTime: travel.exploredTimestamp,
        snapshot: travel.exploredSnapshot,
        diary: travel.diary,
        mood: travel.diaryMood,
        souvenir: travel.souvenir,
      }),
    },
  };
});

/**
 * è·å–æ—…è¡Œå†å²
 * GET /api/travel/history
 */
app.get('/api/travel/history', async (request, reply) => {
  const userId = request.user.id;
  const { limit = 10, offset = 0 } = request.query as any;

  const [travels, total] = await Promise.all([
    prisma.travel.findMany({
      where: { userId, status: 'COMPLETED' },
      orderBy: { completedAt: 'desc' },
      take: Number(limit),
      skip: Number(offset),
      select: {
        id: true,
        targetChain: true,
        exploredBlock: true,
        exploredTimestamp: true,
        diary: true,
        diaryMood: true,
        souvenir: true,
        completedAt: true,
      },
    }),
    prisma.travel.count({ where: { userId, status: 'COMPLETED' } }),
  ]);

  return {
    success: true,
    data: { travels, total },
  };
});

/**
 * è·å–ç”¨æˆ·ç»Ÿè®¡
 * GET /api/travel/stats
 */
app.get('/api/travel/stats', async (request, reply) => {
  const userId = request.user.id;

  const stats = await prisma.userTravelStats.findUnique({
    where: { userId },
  });

  return {
    success: true,
    data: stats || {
      totalTrips: 0,
      bscTrips: 0,
      ethTrips: 0,
      zetaTrips: 0,
    },
  };
});
```

### 5.2 å¾½ç«  API

```typescript
// src/routes/badge.routes.ts

/**
 * è·å–æ‰€æœ‰å¾½ç« ï¼ˆå«è§£é”çŠ¶æ€ï¼‰
 * GET /api/badges
 */
app.get('/api/badges', async (request, reply) => {
  const userId = request.user.id;

  const badges = await badgeService.getAllBadgesWithStatus(userId);

  return {
    success: true,
    data: badges,
  };
});

/**
 * è·å–å·²è§£é”å¾½ç« 
 * GET /api/badges/unlocked
 */
app.get('/api/badges/unlocked', async (request, reply) => {
  const userId = request.user.id;

  const badges = await badgeService.getUserBadges(userId);

  return {
    success: true,
    data: badges,
  };
});
```

---

## 6. å‰ç«¯é¡µé¢è®¾è®¡

### 6.1 ä¸»é¡µé¢ï¼ˆä¿æŒç®€æ´ï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                             â”‚
â”‚                      ğŸ  é’è›™çš„å°çª                           â”‚
â”‚                                                             â”‚
â”‚                         ğŸ¸                                  â”‚
â”‚                   ï¼ˆé’è›™å¾…æœºåŠ¨ç”»ï¼‰                            â”‚
â”‚                                                             â”‚
â”‚                    "å‘±~ æƒ³å‡ºé—¨äº†"                            â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚   â”‚
â”‚  â”‚      â”‚     ğŸ’ è®©é’è›™å‡ºé—¨æ—…è¡Œ               â”‚       â”‚   â”‚
â”‚  â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚      å¯é€‰è®¾ç½®ï¼š                                      â”‚   â”‚
â”‚  â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚   â”‚
â”‚  â”‚      â”‚ ğŸ“ æŒ‡å®šè§‚å¯Ÿçš„é’±åŒ…ï¼ˆå¯ä¸å¡«ï¼‰            â”‚       â”‚   â”‚
â”‚  â”‚      â”‚    0x...                             â”‚       â”‚   â”‚
â”‚  â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚   â”‚
â”‚  â”‚      â”‚ ğŸ² éšæœºæ—…è¡Œï¼ˆæ¨èï¼‰        âœ“    â”‚           â”‚   â”‚
â”‚  â”‚      â”‚ ğŸ“ æŒ‡å®šå»æŸæ¡é“¾                  â”‚           â”‚   â”‚
â”‚  â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚ ğŸ“– æ—¥è®° â”‚  â”‚ ğŸ çºªå¿µå“â”‚  â”‚ ğŸ† å¾½ç«  â”‚                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 æ—…è¡Œä¸­é¡µé¢

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                             â”‚
â”‚                    ğŸ¸ é’è›™å‡ºé—¨äº†...                          â”‚
â”‚                                                             â”‚
â”‚                         ğŸ’                                  â”‚
â”‚                    ï¼ˆèµ°è·¯åŠ¨ç”»ï¼‰                              â”‚
â”‚                                                             â”‚
â”‚                                                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 60%                â”‚
â”‚                                                             â”‚
â”‚                                                             â”‚
â”‚            âœ“ èƒŒä¸Šå°ä¹¦åŒ…                                      â”‚
â”‚            âœ“ è·³å‡ºå®¶é—¨                                        â”‚
â”‚            â†’ æ¢ç´¢ä¸­...                                       â”‚
â”‚            â—‹ å‘ç°æœ‰è¶£çš„ä¸œè¥¿                                   â”‚
â”‚            â—‹ å†™æ—…è¡Œæ—¥è®°                                      â”‚
â”‚            â—‹ è¹¦è¹¦è·³è·³å›å®¶                                    â”‚
â”‚                                                             â”‚
â”‚                                                             â”‚
â”‚              "ä¸çŸ¥é“é’è›™å»å“ªäº†å‘¢..."                          â”‚
â”‚                                                             â”‚
â”‚              ç­‰å®ƒå›æ¥ä¼šå¸¦ç¤¼ç‰©çš„ ğŸ                            â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.3 æ—…è¡Œç»“æœé¡µé¢

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ğŸ¸ é’è›™å›æ¥å•¦ï¼                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ğŸ“– æ—…è¡Œæ—¥è®°                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚  # åœ¨ BSC å‘ç°äº†å¥½å¤šæœ‰è¶£çš„ä¸œè¥¿                        â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚  å‘±~ ä»Šå¤©å»äº†å¸å®‰æµ‹è¯•é“¾ç©ï¼                           â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚  è·¯è¿‡ä¸€ä¸ªå°é’±åŒ…ï¼Œé‡Œé¢åªæœ‰ 0.1 ä¸ªé‡‘å¸ï¼Œ               â”‚   â”‚
â”‚  â”‚  çœ‹èµ·æ¥æ˜¯ä¸ªåˆšå¼€å§‹å†’é™©çš„æ–°äººå‘¢ã€‚                       â”‚   â”‚
â”‚  â”‚  åœ¨æ—è¾¹çš„è‰ä¸›é‡Œæ¡åˆ°ä¸€ç‰‡æ¼‚äº®çš„è½å¶ï¼Œ                   â”‚   â”‚
â”‚  â”‚  å†³å®šå¸¦å›å®¶å½“çºªå¿µå“ï¼                                 â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚  æœ‰ç‚¹ç´¯äº†ï¼Œæƒ³å›å®¶ç¡è§‰... ğŸ˜´                          â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  ğŸ å¸¦å›çš„çºªå¿µå“                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  ğŸ‚ é‡‘è‰²è½å¶                                         â”‚   â”‚
â”‚  â”‚  "ä» BSC æµ‹è¯•é“¾çš„å¤§æ ‘ä¸Šé£˜è½"                         â”‚   â”‚
â”‚  â”‚  ç¨€æœ‰åº¦ï¼šâ­â­                                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  ğŸ“¸ æ—…è¡Œå¿«ç…§                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  ğŸŒ BSC æµ‹è¯•ç½‘  ğŸ“ åŒºå— #12345678                    â”‚   â”‚
â”‚  â”‚  ğŸ“… 2024å¹´6æœˆ15æ—¥                                    â”‚   â”‚
â”‚  â”‚  ğŸ’° è§‚å¯Ÿåˆ°ï¼š0.1 tBNB  ğŸ“Š 5ç¬”äº¤æ˜“                     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  ğŸ† è·å¾—å¾½ç« ï¼šç¬¬ä¸€æ¬¡å‡ºé—¨ ğŸ’                                  â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚  â”‚   å†å‡ºå‘ï¼   â”‚  â”‚   è¿”å›é¦–é¡µ  â”‚                           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 7. P0 é‡Œç¨‹ç¢‘

| å‘¨æ¬¡ | ä»»åŠ¡ | äº¤ä»˜ç‰© |
|------|------|--------|
| **Week 1** | æ•°æ®åº“å‡çº§ | Prisma Schema ä¿®æ”¹ã€è¿ç§»è„šæœ¬ |
| **Week 2** | æ¢ç´¢æœåŠ¡ | 3æ¡æµ‹è¯•é“¾ Providerã€exploration.service |
| **Week 3** | çºªå¿µå“ & AI æ—¥è®° | souvenir.generatorã€AI Prompt |
| **Week 4** | å¾½ç« ç³»ç»Ÿ | badge.serviceã€å¾½ç« ç§å­æ•°æ® |
| **Week 5** | API & Worker | è·¯ç”±æ‰©å±•ã€é˜Ÿåˆ—å¤„ç† |
| **Week 6** | å‰ç«¯ & æµ‹è¯• | UI é¡µé¢ã€E2E æµ‹è¯• |

---

## 8. P0 å®Œæˆæ ‡å‡†

- [ ] ä¸€é”®å‡ºå‘ï¼Œé’è›™éšæœºé€‰æ‹©ç›®çš„åœ°
- [ ] æ”¯æŒå¯é€‰æŒ‡å®šé’±åŒ…è§‚å¯Ÿ
- [ ] æ”¯æŒ BSC/ETH/ZETA ä¸‰æ¡æµ‹è¯•é“¾
- [ ] AI ç”Ÿæˆå¯çˆ±çš„æ—…è¡Œæ—¥è®°
- [ ] æ¯æ¬¡æ—…è¡Œå¸¦å›ä¸€ä¸ªçºªå¿µå“
- [ ] 10+ ç§å¾½ç« å¯è§£é”
- [ ] å‰ç«¯äº¤äº’æµç•…è‡ªç„¶
- [ ] æ•´ä½“ä½“éªŒåƒã€Œæ—…è¡Œé’è›™ã€è€Œä¸æ˜¯å·¥å…·

---

è¿™ä»½ P0 éœ€æ±‚æŠŠé‡ç‚¹æ”¾å›ã€Œéšæœºæ€§ã€å’Œã€ŒæƒŠå–œæ„Ÿã€ï¼Œè®©ç”¨æˆ·çš„æ“ä½œå˜å¾—å¾ˆç®€å•â€”â€”**å°±æ˜¯è®©é’è›™å‡ºé—¨ï¼Œç„¶åç­‰å®ƒå›æ¥çœ‹çœ‹å¸¦äº†ä»€ä¹ˆ**ã€‚è¿™æ‰æ˜¯æ—…è¡Œé’è›™çš„ç²¾é«“ï¼

è¦æˆ‘ç»§ç»­ç»†åŒ–å“ªä¸ªéƒ¨åˆ†å—ï¼Ÿ