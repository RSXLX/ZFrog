# ğŸ¸ ZetaFrog æ¡Œé¢å® ç‰©åŠ¨ç”»ä¸äº’åŠ¨æ–¹æ¡ˆ

## ğŸ“‹ æ–¹æ¡ˆæ¦‚è¿°

è®¾è®¡ä¸€ä¸ªæœ‰åˆ›æ„ã€å¯äº’åŠ¨ã€èƒ½å®æ—¶ç›‘æ§é“¾ä¸Šå¤§å•çš„æ¡Œé¢é’è›™å® ç‰©ï¼Œæ‰“é€ æ²‰æµ¸å¼çš„ Web3 æ¡Œå® ä½“éªŒã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ZetaFrog æ¡Œé¢å® ç‰©ç³»ç»Ÿ                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   åŠ¨ç”»å¼•æ“      â”‚   â”‚   äº’åŠ¨ç³»ç»Ÿ      â”‚   â”‚   é“¾ä¸Šç›‘æ§          â”‚  â”‚
â”‚   â”‚                 â”‚   â”‚                 â”‚   â”‚                     â”‚  â”‚
â”‚   â”‚ â€¢ çŠ¶æ€åŠ¨ç”»      â”‚   â”‚ â€¢ ç‚¹å‡»äº’åŠ¨      â”‚   â”‚ â€¢ å¤§å•æ£€æµ‹          â”‚  â”‚
â”‚   â”‚ â€¢ è¡¨æƒ…ç³»ç»Ÿ      â”‚   â”‚ â€¢ æ‹–æ‹½ç§»åŠ¨      â”‚   â”‚ â€¢ å®æ—¶ä»·æ ¼          â”‚  â”‚
â”‚   â”‚ â€¢ ç²’å­æ•ˆæœ      â”‚   â”‚ â€¢ è¯­éŸ³/æ–‡å­—     â”‚   â”‚ â€¢ Gas ç›‘æ§          â”‚  â”‚
â”‚   â”‚ â€¢ åœºæ™¯åˆ‡æ¢      â”‚   â”‚ â€¢ å–‚é£Ÿç³»ç»Ÿ      â”‚   â”‚ â€¢ é²¸é±¼è¿½è¸ª          â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                          â”‚
â”‚                              â–¼                                          â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚
â”‚                    â”‚    é’è›™ååº”ç³»ç»Ÿ     â”‚                              â”‚
â”‚                    â”‚   æ ¹æ®é“¾ä¸Šäº‹ä»¶      â”‚                              â”‚
â”‚                    â”‚   è§¦å‘ç‰¹æ®ŠåŠ¨ç”»      â”‚                              â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¨ ä¸€ã€åŠ¨ç”»çŠ¶æ€ç³»ç»Ÿ

### 1.1 é’è›™çŠ¶æ€æœº

```typescript
// src/types/frogAnimation.ts

export enum FrogState {
  // åŸºç¡€çŠ¶æ€
  IDLE = 'idle',              // å¾…æœº - æ­£å¸¸å‘¼å¸
  SLEEPING = 'sleeping',      // ç¡è§‰ - ZZZ
  EATING = 'eating',          // åƒä¸œè¥¿
  WALKING = 'walking',        // èµ°è·¯
  JUMPING = 'jumping',        // è·³è·ƒ
  
  // æ—…è¡ŒçŠ¶æ€
  TRAVELING = 'traveling',    // æ—…è¡Œä¸­ - å¸¦å°èƒŒåŒ…
  RETURNING = 'returning',    // è¿”ç¨‹ - å¸¦çºªå¿µå“
  WRITING = 'writing',        // å†™æ—¥è®°
  
  // é“¾ä¸Šäº‹ä»¶ååº”
  EXCITED = 'excited',        // å…´å¥‹ - å¤§å•ä¹°å…¥
  SCARED = 'scared',          // å®³æ€• - å¤§å•å–å‡º/æš´è·Œ
  RICH = 'rich',              // å‘è´¢ - å·¨é²¸äº¤æ˜“
  CURIOUS = 'curious',        // å¥½å¥‡ - æ–°é¡¹ç›®
  DANCING = 'dancing',        // è·³èˆ - è¡Œæƒ…å¤§æ¶¨
  CRYING = 'crying',          // å“­æ³£ - è¡Œæƒ…æš´è·Œ
  
  // äº’åŠ¨çŠ¶æ€
  HAPPY = 'happy',            // å¼€å¿ƒ - è¢«æŠšæ‘¸
  ANGRY = 'angry',            // ç”Ÿæ°” - è¢«æˆ³å¤ªå¤šæ¬¡
  LOVE = 'love',              // çˆ±å¿ƒ - è¢«å–‚é£Ÿ
  THINKING = 'thinking',      // æ€è€ƒ - ç­‰å¾…ç”¨æˆ·æ“ä½œ
}

export enum FrogMood {
  VERY_HAPPY = 'very_happy',
  HAPPY = 'happy',
  NEUTRAL = 'neutral',
  SAD = 'sad',
  VERY_SAD = 'very_sad',
}

export interface FrogAnimationState {
  currentState: FrogState;
  mood: FrogMood;
  energy: number;          // 0-100 ç²¾åŠ›å€¼
  hunger: number;          // 0-100 é¥¥é¥¿å€¼
  happiness: number;       // 0-100 å¿«ä¹å€¼
  lastInteraction: number; // ä¸Šæ¬¡äº’åŠ¨æ—¶é—´
  position: { x: number; y: number };
  direction: 'left' | 'right';
}
```

### 1.2 åŠ¨ç”»é…ç½®

```typescript
// src/config/animations.ts

export const ANIMATION_CONFIGS = {
  // åŸºç¡€çŠ¶æ€åŠ¨ç”»
  [FrogState.IDLE]: {
    frames: 4,
    duration: 2000,
    loop: true,
    sprites: [
      '/assets/frog/idle_1.png',
      '/assets/frog/idle_2.png',
      '/assets/frog/idle_3.png',
      '/assets/frog/idle_2.png',
    ],
    particles: null,
    sound: null,
  },
  
  [FrogState.SLEEPING]: {
    frames: 3,
    duration: 3000,
    loop: true,
    sprites: [
      '/assets/frog/sleep_1.png',
      '/assets/frog/sleep_2.png',
      '/assets/frog/sleep_3.png',
    ],
    particles: 'zzz',
    sound: '/sounds/snore.mp3',
  },
  
  [FrogState.EXCITED]: {
    frames: 6,
    duration: 800,
    loop: true,
    sprites: [
      '/assets/frog/excited_1.png',
      '/assets/frog/excited_2.png',
      '/assets/frog/excited_3.png',
      '/assets/frog/excited_4.png',
      '/assets/frog/excited_5.png',
      '/assets/frog/excited_6.png',
    ],
    particles: 'stars',
    sound: '/sounds/excited.mp3',
  },
  
  [FrogState.RICH]: {
    frames: 8,
    duration: 1500,
    loop: true,
    sprites: [
      '/assets/frog/rich_1.png',
      '/assets/frog/rich_2.png',
      // ... é‡‘å¸é£èˆåŠ¨ç”»
    ],
    particles: 'coins',
    sound: '/sounds/cha-ching.mp3',
  },
  
  [FrogState.SCARED]: {
    frames: 4,
    duration: 500,
    loop: false,
    sprites: [
      '/assets/frog/scared_1.png',
      '/assets/frog/scared_2.png',
      '/assets/frog/scared_3.png',
      '/assets/frog/scared_4.png',
    ],
    particles: 'sweat',
    sound: '/sounds/scared.mp3',
  },
  
  [FrogState.DANCING]: {
    frames: 12,
    duration: 2000,
    loop: true,
    sprites: [
      // è·³èˆåŠ¨ç”»å¸§
    ],
    particles: 'music_notes',
    sound: '/sounds/dance_music.mp3',
  },
  
  // ... å…¶ä»–çŠ¶æ€é…ç½®
};

// ç²’å­æ•ˆæœé…ç½®
export const PARTICLE_CONFIGS = {
  zzz: {
    emoji: 'ğŸ’¤',
    count: 3,
    duration: 2000,
    direction: 'up',
    spread: 30,
  },
  stars: {
    emoji: 'â­',
    count: 8,
    duration: 1000,
    direction: 'burst',
    spread: 360,
  },
  coins: {
    emoji: 'ğŸª™',
    count: 15,
    duration: 1500,
    direction: 'up',
    spread: 60,
  },
  hearts: {
    emoji: 'â¤ï¸',
    count: 5,
    duration: 1200,
    direction: 'up',
    spread: 45,
  },
  sweat: {
    emoji: 'ğŸ’¦',
    count: 3,
    duration: 800,
    direction: 'right',
    spread: 20,
  },
  music_notes: {
    emoji: 'ğŸµ',
    count: 6,
    duration: 1500,
    direction: 'up',
    spread: 90,
  },
  fire: {
    emoji: 'ğŸ”¥',
    count: 10,
    duration: 1000,
    direction: 'up',
    spread: 45,
  },
  tears: {
    emoji: 'ğŸ˜¢',
    count: 4,
    duration: 1000,
    direction: 'down',
    spread: 30,
  },
};
```

### 1.3 åŠ¨ç”»ç»„ä»¶å®ç°

```tsx
// src/components/frog/FrogPet.tsx

import { useRef, useEffect, useState, useCallback } from 'react';
import { motion, useAnimation, AnimatePresence } from 'framer-motion';
import { useFrogState } from '../../hooks/useFrogState';
import { useChainMonitor } from '../../hooks/useChainMonitor';
import { ParticleEffect } from './ParticleEffect';
import { SpeechBubble } from './SpeechBubble';
import { FrogState, FrogMood } from '../../types/frogAnimation';
import { ANIMATION_CONFIGS } from '../../config/animations';

interface FrogPetProps {
  frogId: number;
  name: string;
  initialState?: FrogState;
  onInteract?: (interaction: string) => void;
}

export function FrogPet({ frogId, name, initialState = FrogState.IDLE, onInteract }: FrogPetProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const controls = useAnimation();
  
  // é’è›™çŠ¶æ€ç®¡ç†
  const {
    state,
    mood,
    energy,
    position,
    direction,
    setState,
    setMood,
    updateEnergy,
    setPosition,
    setDirection,
  } = useFrogState(initialState);
  
  // é“¾ä¸Šç›‘æ§
  const { 
    latestEvent, 
    priceChange, 
    whaleAlert,
    gasPrice 
  } = useChainMonitor();
  
  // å½“å‰åŠ¨ç”»å¸§
  const [currentFrame, setCurrentFrame] = useState(0);
  const [showSpeech, setShowSpeech] = useState(false);
  const [speechText, setSpeechText] = useState('');
  const [particles, setParticles] = useState<string | null>(null);
  
  // åŠ¨ç”»é…ç½®
  const animConfig = ANIMATION_CONFIGS[state];
  
  // å¸§åŠ¨ç”»å¾ªç¯
  useEffect(() => {
    if (!animConfig) return;
    
    const frameTime = animConfig.duration / animConfig.frames;
    const interval = setInterval(() => {
      setCurrentFrame(prev => {
        if (prev >= animConfig.frames - 1) {
          return animConfig.loop ? 0 : prev;
        }
        return prev + 1;
      });
    }, frameTime);
    
    return () => clearInterval(interval);
  }, [state, animConfig]);
  
  // é“¾ä¸Šäº‹ä»¶ååº”
  useEffect(() => {
    if (!latestEvent) return;
    
    handleChainEvent(latestEvent);
  }, [latestEvent]);
  
  // é²¸é±¼è­¦æŠ¥ååº”
  useEffect(() => {
    if (!whaleAlert) return;
    
    handleWhaleAlert(whaleAlert);
  }, [whaleAlert]);
  
  // ä»·æ ¼å˜åŒ–ååº”
  useEffect(() => {
    handlePriceChange(priceChange);
  }, [priceChange]);
  
  // å¤„ç†é“¾ä¸Šäº‹ä»¶
  const handleChainEvent = useCallback((event: any) => {
    const { type, value, token } = event;
    
    switch (type) {
      case 'large_buy':
        triggerReaction(FrogState.EXCITED, `å“‡ï¼æœ‰äººä¹°äº† ${value} ${token}ï¼ğŸš€`, 'stars');
        break;
      case 'large_sell':
        triggerReaction(FrogState.SCARED, `å•Šï¼å¤§å•å–å‡º ${value} ${token}ï¼ğŸ˜±`, 'sweat');
        break;
      case 'whale_transfer':
        triggerReaction(FrogState.RICH, `å·¨é²¸å‡ºåŠ¨ï¼${value} ${token} åœ¨ç§»åŠ¨ï¼ğŸ‹`, 'coins');
        break;
      case 'new_listing':
        triggerReaction(FrogState.CURIOUS, `å‘ç°æ–°é¡¹ç›®ï¼š${token}ï¼ğŸ”`, 'stars');
        break;
    }
  }, []);
  
  // å¤„ç†é²¸é±¼è­¦æŠ¥
  const handleWhaleAlert = useCallback((alert: any) => {
    const { amount, token, direction } = alert;
    
    if (direction === 'in') {
      triggerReaction(
        FrogState.EXCITED, 
        `ğŸ‹ é²¸é±¼ä¹°å…¥ ${formatAmount(amount)} ${token}ï¼`, 
        'coins'
      );
    } else {
      triggerReaction(
        FrogState.SCARED, 
        `ğŸ‹ é²¸é±¼å–å‡º ${formatAmount(amount)} ${token}ï¼`, 
        'sweat'
      );
    }
  }, []);
  
  // å¤„ç†ä»·æ ¼å˜åŒ–
  const handlePriceChange = useCallback((change: number) => {
    if (Math.abs(change) < 5) return; // å°äº 5% ä¸ååº”
    
    if (change >= 20) {
      triggerReaction(FrogState.DANCING, `æš´æ¶¨ ${change.toFixed(1)}%ï¼èµ·é£ï¼ğŸš€ğŸŒ™`, 'fire');
    } else if (change >= 10) {
      triggerReaction(FrogState.EXCITED, `æ¶¨äº† ${change.toFixed(1)}%ï¼ä¸é”™ï¼ğŸ“ˆ`, 'stars');
    } else if (change <= -20) {
      triggerReaction(FrogState.CRYING, `æš´è·Œ ${change.toFixed(1)}%ï¼å‘œå‘œ...ğŸ’”`, 'tears');
    } else if (change <= -10) {
      triggerReaction(FrogState.SCARED, `è·Œäº† ${change.toFixed(1)}%ï¼å°å¿ƒï¼ğŸ“‰`, 'sweat');
    }
  }, []);
  
  // è§¦å‘ååº”
  const triggerReaction = useCallback((
    newState: FrogState, 
    text: string, 
    particleType: string | null
  ) => {
    setState(newState);
    setSpeechText(text);
    setShowSpeech(true);
    setParticles(particleType);
    
    // æ’­æ”¾éŸ³æ•ˆ
    if (animConfig?.sound) {
      const audio = new Audio(animConfig.sound);
      audio.volume = 0.3;
      audio.play().catch(() => {});
    }
    
    // 5 ç§’åæ¢å¤æ­£å¸¸
    setTimeout(() => {
      setState(FrogState.IDLE);
      setShowSpeech(false);
      setParticles(null);
    }, 5000);
  }, [animConfig]);
  
  // ç‚¹å‡»äº’åŠ¨
  const handleClick = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    
    // è¿ç»­ç‚¹å‡»è®¡æ•°
    const now = Date.now();
    const clickCount = getClickCount(now);
    
    if (clickCount > 10) {
      // ç‚¹å¤ªå¤šæ¬¡ä¼šç”Ÿæ°”
      triggerReaction(FrogState.ANGRY, 'åˆ«æˆ³äº†ï¼ç”Ÿæ°”äº†ï¼ğŸ˜¤', null);
    } else if (clickCount > 5) {
      triggerReaction(FrogState.HAPPY, 'å˜¿å˜¿ï¼Œå¥½ç—’ï¼ğŸ¤­', 'hearts');
    } else {
      // éšæœºååº”
      const reactions = [
        { state: FrogState.HAPPY, text: 'ä½ å¥½å‘€ï¼ğŸ‘‹', particles: 'hearts' },
        { state: FrogState.JUMPING, text: 'å‘±å‘±ï¼ğŸ¸', particles: 'stars' },
        { state: FrogState.CURIOUS, text: 'å—¯ï¼Ÿæœ‰ä»€ä¹ˆäº‹ï¼ŸğŸ¤”', particles: null },
      ];
      const reaction = reactions[Math.floor(Math.random() * reactions.length)];
      triggerReaction(reaction.state, reaction.text, reaction.particles);
    }
    
    onInteract?.('click');
  }, [onInteract, triggerReaction]);
  
  // åŒå‡»äº’åŠ¨
  const handleDoubleClick = useCallback(() => {
    triggerReaction(FrogState.LOVE, 'æœ€å–œæ¬¢ä½ äº†ï¼â¤ï¸', 'hearts');
    onInteract?.('double_click');
  }, [onInteract, triggerReaction]);
  
  // æ‹–æ‹½ç›¸å…³
  const [isDragging, setIsDragging] = useState(false);
  
  const handleDragStart = useCallback(() => {
    setIsDragging(true);
    setState(FrogState.SCARED);
    setSpeechText('å•Šå•Šå•Šï¼æ”¾æˆ‘ä¸‹æ¥ï¼ğŸ˜µ');
    setShowSpeech(true);
  }, []);
  
  const handleDragEnd = useCallback((e: any, info: any) => {
    setIsDragging(false);
    setPosition({
      x: position.x + info.offset.x,
      y: position.y + info.offset.y,
    });
    setState(FrogState.IDLE);
    setShowSpeech(false);
    onInteract?.('drag');
  }, [position, onInteract]);

  return (
    <motion.div
      ref={containerRef}
      className="relative select-none"
      style={{ 
        width: 200, 
        height: 200,
        x: position.x,
        y: position.y,
      }}
      drag
      dragMomentum={false}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      whileDrag={{ scale: 1.1 }}
    >
      {/* é˜´å½± */}
      <motion.div
        className="absolute bottom-0 left-1/2 -translate-x-1/2 w-24 h-4 bg-black/20 rounded-full blur-sm"
        animate={{
          scale: state === FrogState.JUMPING ? [1, 0.5, 1] : 1,
          opacity: state === FrogState.JUMPING ? [0.3, 0.1, 0.3] : 0.3,
        }}
        transition={{ duration: 0.5 }}
      />
      
      {/* é’è›™ä¸»ä½“ */}
      <motion.div
        className="relative cursor-pointer"
        onClick={handleClick}
        onDoubleClick={handleDoubleClick}
        animate={controls}
        style={{
          transform: `scaleX(${direction === 'left' ? -1 : 1})`,
        }}
      >
        {/* é’è›™ç²¾çµå›¾ */}
        <motion.img
          src={animConfig?.sprites?.[currentFrame] || '/assets/frog/idle_1.png'}
          alt={name}
          className="w-full h-full object-contain"
          animate={{
            y: state === FrogState.JUMPING ? [0, -30, 0] : 
               state === FrogState.IDLE ? [0, -3, 0] : 0,
            rotate: state === FrogState.DANCING ? [0, -10, 10, 0] :
                    state === FrogState.SCARED ? [-5, 5, -5, 5, 0] : 0,
            scale: state === FrogState.EXCITED ? [1, 1.1, 1] : 1,
          }}
          transition={{
            duration: state === FrogState.JUMPING ? 0.5 :
                     state === FrogState.IDLE ? 2 :
                     state === FrogState.DANCING ? 0.5 : 0.3,
            repeat: state === FrogState.IDLE || state === FrogState.DANCING ? Infinity : 0,
            ease: 'easeInOut',
          }}
          draggable={false}
        />
        
        {/* çœ¼ç›åŠ¨ç”»ï¼ˆè¦†ç›–å±‚ï¼‰ */}
        <FrogEyes state={state} mood={mood} />
        
        {/* é…ä»¶å±‚ */}
        <FrogAccessories state={state} />
      </motion.div>
      
      {/* ç²’å­æ•ˆæœ */}
      <AnimatePresence>
        {particles && (
          <ParticleEffect 
            type={particles} 
            onComplete={() => setParticles(null)}
          />
        )}
      </AnimatePresence>
      
      {/* å¯¹è¯æ°”æ³¡ */}
      <AnimatePresence>
        {showSpeech && (
          <SpeechBubble 
            text={speechText} 
            position="top"
            onClose={() => setShowSpeech(false)}
          />
        )}
      </AnimatePresence>
      
      {/* çŠ¶æ€æŒ‡ç¤ºå™¨ */}
      <StatusIndicators 
        energy={energy} 
        mood={mood} 
        state={state}
      />
      
      {/* åå­—æ ‡ç­¾ */}
      <motion.div
        className="absolute -bottom-6 left-1/2 -translate-x-1/2 bg-white/90 backdrop-blur-sm px-3 py-1 rounded-full shadow-sm"
        initial={{ opacity: 0, y: -10 }}
        animate={{ opacity: 1, y: 0 }}
      >
        <span className="text-sm font-medium text-gray-700">{name}</span>
      </motion.div>
    </motion.div>
  );
}

// é’è›™çœ¼ç›ç»„ä»¶
function FrogEyes({ state, mood }: { state: FrogState; mood: FrogMood }) {
  const eyeVariants = {
    [FrogState.IDLE]: { scaleY: 1 },
    [FrogState.SLEEPING]: { scaleY: 0.1 },
    [FrogState.EXCITED]: { scaleY: 1.2 },
    [FrogState.SCARED]: { scaleY: 1.5 },
    [FrogState.HAPPY]: { scaleY: 0.8 },
    [FrogState.ANGRY]: { scaleY: 0.6 },
  };
  
  const eyeStyle = eyeVariants[state] || eyeVariants[FrogState.IDLE];
  
  return (
    <div className="absolute top-[30%] left-1/2 -translate-x-1/2 flex gap-4">
      <motion.div
        className="w-6 h-6 bg-white rounded-full flex items-center justify-center"
        animate={eyeStyle}
      >
        <motion.div 
          className="w-3 h-3 bg-black rounded-full"
          animate={{
            x: state === FrogState.CURIOUS ? [0, 2, -2, 0] : 0,
          }}
          transition={{ duration: 2, repeat: Infinity }}
        />
      </motion.div>
      <motion.div
        className="w-6 h-6 bg-white rounded-full flex items-center justify-center"
        animate={eyeStyle}
      >
        <motion.div 
          className="w-3 h-3 bg-black rounded-full"
          animate={{
            x: state === FrogState.CURIOUS ? [0, 2, -2, 0] : 0,
          }}
          transition={{ duration: 2, repeat: Infinity }}
        />
      </motion.div>
    </div>
  );
}

// é…ä»¶ç»„ä»¶
function FrogAccessories({ state }: { state: FrogState }) {
  return (
    <>
      {/* æ—…è¡ŒèƒŒåŒ… */}
      {state === FrogState.TRAVELING && (
        <motion.div
          className="absolute -right-2 top-1/2 text-2xl"
          initial={{ opacity: 0, x: -10 }}
          animate={{ opacity: 1, x: 0 }}
        >
          ğŸ’
        </motion.div>
      )}
      
      {/* è¿”ç¨‹çºªå¿µå“ */}
      {state === FrogState.RETURNING && (
        <motion.div
          className="absolute -left-2 top-1/3 text-xl"
          initial={{ opacity: 0, scale: 0 }}
          animate={{ opacity: 1, scale: 1 }}
        >
          ğŸ
        </motion.div>
      )}
      
      {/* å†™æ—¥è®°çš„ç¬” */}
      {state === FrogState.WRITING && (
        <motion.div
          className="absolute -right-4 top-1/3 text-xl"
          animate={{ rotate: [0, -15, 0] }}
          transition={{ duration: 0.5, repeat: Infinity }}
        >
          âœï¸
        </motion.div>
      )}
      
      {/* ç¡å¸½ */}
      {state === FrogState.SLEEPING && (
        <motion.div
          className="absolute -top-4 left-1/2 -translate-x-1/2 text-2xl"
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
        >
          ğŸ§¢
        </motion.div>
      )}
      
      {/* å‘è´¢å¢¨é•œ */}
      {state === FrogState.RICH && (
        <motion.div
          className="absolute top-[25%] left-1/2 -translate-x-1/2 text-2xl"
          initial={{ opacity: 0, scale: 0 }}
          animate={{ opacity: 1, scale: 1 }}
        >
          ğŸ˜
        </motion.div>
      )}
    </>
  );
}

// çŠ¶æ€æŒ‡ç¤ºå™¨
function StatusIndicators({ energy, mood, state }: { 
  energy: number; 
  mood: FrogMood; 
  state: FrogState;
}) {
  const moodEmoji = {
    [FrogMood.VERY_HAPPY]: 'ğŸ˜„',
    [FrogMood.HAPPY]: 'ğŸ™‚',
    [FrogMood.NEUTRAL]: 'ğŸ˜',
    [FrogMood.SAD]: 'ğŸ˜”',
    [FrogMood.VERY_SAD]: 'ğŸ˜¢',
  };
  
  return (
    <div className="absolute -top-8 right-0 flex gap-1">
      {/* å¿ƒæƒ… */}
      <motion.div
        className="text-lg"
        animate={{ scale: [1, 1.2, 1] }}
        transition={{ duration: 2, repeat: Infinity }}
      >
        {moodEmoji[mood]}
      </motion.div>
      
      {/* ç²¾åŠ›æ¡ */}
      <div className="w-12 h-2 bg-gray-200 rounded-full overflow-hidden">
        <motion.div
          className="h-full bg-gradient-to-r from-green-400 to-emerald-500 rounded-full"
          animate={{ width: `${energy}%` }}
        />
      </div>
    </div>
  );
}

// è¾…åŠ©å‡½æ•°
function formatAmount(amount: number): string {
  if (amount >= 1000000) return `${(amount / 1000000).toFixed(1)}M`;
  if (amount >= 1000) return `${(amount / 1000).toFixed(1)}K`;
  return amount.toFixed(2);
}

function getClickCount(now: number): number {
  // å®ç°ç‚¹å‡»è®¡æ•°é€»è¾‘
  return 1;
}
```

---

## âœ¨ äºŒã€ç²’å­æ•ˆæœç³»ç»Ÿ

```tsx
// src/components/frog/ParticleEffect.tsx

import { motion } from 'framer-motion';
import { useEffect, useState } from 'react';
import { PARTICLE_CONFIGS } from '../../config/animations';

interface ParticleEffectProps {
  type: string;
  onComplete?: () => void;
}

interface Particle {
  id: number;
  emoji: string;
  x: number;
  y: number;
  angle: number;
  delay: number;
}

export function ParticleEffect({ type, onComplete }: ParticleEffectProps) {
  const [particles, setParticles] = useState<Particle[]>([]);
  const config = PARTICLE_CONFIGS[type];
  
  useEffect(() => {
    if (!config) return;
    
    // ç”Ÿæˆç²’å­
    const newParticles: Particle[] = [];
    for (let i = 0; i < config.count; i++) {
      const angle = config.direction === 'burst' 
        ? (360 / config.count) * i 
        : (Math.random() - 0.5) * config.spread;
      
      newParticles.push({
        id: i,
        emoji: config.emoji,
        x: (Math.random() - 0.5) * 40,
        y: 0,
        angle,
        delay: i * 50,
      });
    }
    setParticles(newParticles);
    
    // åŠ¨ç”»å®Œæˆåå›è°ƒ
    const timer = setTimeout(() => {
      onComplete?.();
    }, config.duration + 500);
    
    return () => clearTimeout(timer);
  }, [type, config, onComplete]);
  
  if (!config) return null;
  
  const getEndPosition = (particle: Particle) => {
    const distance = 80 + Math.random() * 40;
    const rad = (particle.angle * Math.PI) / 180;
    
    switch (config.direction) {
      case 'up':
        return { x: particle.x, y: -distance };
      case 'down':
        return { x: particle.x, y: distance };
      case 'burst':
        return {
          x: Math.cos(rad) * distance,
          y: Math.sin(rad) * distance,
        };
      default:
        return { x: distance * 0.5, y: -distance * 0.5 };
    }
  };
  
  return (
    <div className="absolute inset-0 pointer-events-none overflow-visible">
      {particles.map((particle) => {
        const end = getEndPosition(particle);
        
        return (
          <motion.div
            key={particle.id}
            className="absolute left-1/2 top-1/2 text-2xl"
            initial={{
              x: particle.x,
              y: particle.y,
              scale: 0,
              opacity: 1,
            }}
            animate={{
              x: end.x,
              y: end.y,
              scale: [0, 1.2, 1, 0.5],
              opacity: [0, 1, 1, 0],
              rotate: Math.random() * 360,
            }}
            transition={{
              duration: config.duration / 1000,
              delay: particle.delay / 1000,
              ease: 'easeOut',
            }}
          >
            {particle.emoji}
          </motion.div>
        );
      })}
    </div>
  );
}

// é¢„è®¾ç²’å­æ•ˆæœ
export function CoinShower({ count = 20 }: { count?: number }) {
  return (
    <div className="absolute inset-0 pointer-events-none">
      {Array.from({ length: count }).map((_, i) => (
        <motion.div
          key={i}
          className="absolute text-2xl"
          initial={{
            x: Math.random() * 200 - 100,
            y: -50,
            rotate: 0,
          }}
          animate={{
            y: 200,
            rotate: 360,
            opacity: [1, 1, 0],
          }}
          transition={{
            duration: 2,
            delay: Math.random() * 1,
            ease: 'easeIn',
          }}
        >
          ğŸª™
        </motion.div>
      ))}
    </div>
  );
}

export function HeartBurst({ count = 10 }: { count?: number }) {
  return (
    <div className="absolute inset-0 pointer-events-none">
      {Array.from({ length: count }).map((_, i) => {
        const angle = (360 / count) * i;
        const rad = (angle * Math.PI) / 180;
        const distance = 60 + Math.random() * 30;
        
        return (
          <motion.div
            key={i}
            className="absolute left-1/2 top-1/2 text-xl"
            initial={{ x: 0, y: 0, scale: 0 }}
            animate={{
              x: Math.cos(rad) * distance,
              y: Math.sin(rad) * distance,
              scale: [0, 1.5, 1, 0],
              opacity: [0, 1, 1, 0],
            }}
            transition={{
              duration: 1.2,
              delay: i * 0.05,
              ease: 'easeOut',
            }}
          >
            â¤ï¸
          </motion.div>
        );
      })}
    </div>
  );
}
```

---

## ğŸ’¬ ä¸‰ã€å¯¹è¯æ°”æ³¡ç³»ç»Ÿ

```tsx
// src/components/frog/SpeechBubble.tsx

import { motion } from 'framer-motion';
import { useEffect, useState } from 'react';

interface SpeechBubbleProps {
  text: string;
  position?: 'top' | 'bottom' | 'left' | 'right';
  autoHide?: boolean;
  duration?: number;
  onClose?: () => void;
}

export function SpeechBubble({ 
  text, 
  position = 'top',
  autoHide = true,
  duration = 4000,
  onClose 
}: SpeechBubbleProps) {
  const [displayText, setDisplayText] = useState('');
  const [isTyping, setIsTyping] = useState(true);
  
  // æ‰“å­—æœºæ•ˆæœ
  useEffect(() => {
    setDisplayText('');
    setIsTyping(true);
    
    let index = 0;
    const interval = setInterval(() => {
      if (index < text.length) {
        setDisplayText(text.slice(0, index + 1));
        index++;
      } else {
        setIsTyping(false);
        clearInterval(interval);
      }
    }, 50);
    
    return () => clearInterval(interval);
  }, [text]);
  
  // è‡ªåŠ¨éšè—
  useEffect(() => {
    if (!autoHide) return;
    
    const timer = setTimeout(() => {
      onClose?.();
    }, duration);
    
    return () => clearTimeout(timer);
  }, [autoHide, duration, onClose]);
  
  const positionStyles = {
    top: 'bottom-full left-1/2 -translate-x-1/2 mb-4',
    bottom: 'top-full left-1/2 -translate-x-1/2 mt-4',
    left: 'right-full top-1/2 -translate-y-1/2 mr-4',
    right: 'left-full top-1/2 -translate-y-1/2 ml-4',
  };
  
  const tailStyles = {
    top: 'bottom-0 left-1/2 -translate-x-1/2 translate-y-full border-l-8 border-r-8 border-t-8 border-l-transparent border-r-transparent border-t-white',
    bottom: 'top-0 left-1/2 -translate-x-1/2 -translate-y-full border-l-8 border-r-8 border-b-8 border-l-transparent border-r-transparent border-b-white',
    left: 'right-0 top-1/2 -translate-y-1/2 translate-x-full border-t-8 border-b-8 border-l-8 border-t-transparent border-b-transparent border-l-white',
    right: 'left-0 top-1/2 -translate-y-1/2 -translate-x-full border-t-8 border-b-8 border-r-8 border-t-transparent border-b-transparent border-r-white',
  };
  
  return (
    <motion.div
      className={`absolute ${positionStyles[position]} z-10`}
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.8 }}
      transition={{ type: 'spring', damping: 20 }}
    >
      <div className="relative bg-white rounded-2xl shadow-lg px-4 py-3 max-w-[200px]">
        <p className="text-sm text-gray-800 whitespace-pre-wrap">
          {displayText}
          {isTyping && (
            <motion.span
              animate={{ opacity: [1, 0] }}
              transition={{ duration: 0.5, repeat: Infinity }}
            >
              |
            </motion.span>
          )}
        </p>
        
        {/* æ°”æ³¡å°¾å·´ */}
        <div className={`absolute w-0 h-0 ${tailStyles[position]}`} />
      </div>
    </motion.div>
  );
}

// æ€è€ƒæ°”æ³¡
export function ThinkingBubble({ position = 'top' }: { position?: 'top' | 'right' }) {
  return (
    <motion.div
      className={`absolute ${
        position === 'top' 
          ? 'bottom-full left-1/2 -translate-x-1/2 mb-8' 
          : 'left-full top-0 ml-4'
      }`}
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
    >
      {/* å°åœ†ç‚¹ */}
      <motion.div
        className="absolute -bottom-2 left-1/2 -translate-x-1/2 w-2 h-2 bg-white rounded-full shadow"
        animate={{ scale: [1, 1.2, 1] }}
        transition={{ duration: 1, repeat: Infinity }}
      />
      <motion.div
        className="absolute -bottom-5 left-1/2 -translate-x-1/4 w-3 h-3 bg-white rounded-full shadow"
        animate={{ scale: [1, 1.2, 1] }}
        transition={{ duration: 1, delay: 0.2, repeat: Infinity }}
      />
      
      {/* ä¸»æ°”æ³¡ */}
      <div className="bg-white rounded-full shadow-lg px-4 py-2">
        <motion.span
          className="text-gray-400"
          animate={{ opacity: [0.3, 1, 0.3] }}
          transition={{ duration: 1.5, repeat: Infinity }}
        >
          ğŸ’­ ...
        </motion.span>
      </div>
    </motion.div>
  );
}
```

---

## â›“ï¸ å››ã€é“¾ä¸Šç›‘æ§ç³»ç»Ÿ

```typescript
// src/hooks/useChainMonitor.ts

import { useEffect, useState, useCallback, useRef } from 'react';
import { createPublicClient, http, formatEther, parseAbi } from 'viem';
import { mainnet } from 'viem/chains';
import { zetachainAthens } from '../config/chains';

// ç›‘æ§äº‹ä»¶ç±»å‹
export interface ChainEvent {
  type: 'large_buy' | 'large_sell' | 'whale_transfer' | 'new_listing' | 'price_change';
  token: string;
  value: number;
  from?: string;
  to?: string;
  timestamp: number;
  txHash?: string;
}

export interface WhaleAlert {
  address: string;
  amount: number;
  token: string;
  direction: 'in' | 'out';
  timestamp: number;
}

export interface ChainMonitorState {
  latestEvent: ChainEvent | null;
  priceChange: number;
  whaleAlert: WhaleAlert | null;
  gasPrice: bigint;
  isConnected: boolean;
  events: ChainEvent[];
}

// ç›‘æ§é…ç½®
const MONITOR_CONFIG = {
  // å¤§å•é˜ˆå€¼ (USD)
  largeTradeThreshold: 100000,
  // å·¨é²¸é˜ˆå€¼ (USD)
  whaleThreshold: 1000000,
  // ä»·æ ¼å˜åŒ–è­¦æŠ¥é˜ˆå€¼ (%)
  priceAlertThreshold: 5,
  // ç›‘æ§çš„ä»£å¸åœ°å€
  watchedTokens: [
    { address: '0x...', symbol: 'ZETA', decimals: 18 },
    { address: '0x...', symbol: 'ETH', decimals: 18 },
  ],
  // ç›‘æ§çš„é²¸é±¼åœ°å€
  watchedWhales: [
    '0x...', // å·²çŸ¥é²¸é±¼åœ°å€
  ],
  // è½®è¯¢é—´éš” (ms)
  pollInterval: 10000,
};

export function useChainMonitor() {
  const [state, setState] = useState<ChainMonitorState>({
    latestEvent: null,
    priceChange: 0,
    whaleAlert: null,
    gasPrice: BigInt(0),
    isConnected: false,
    events: [],
  });
  
  const clientRef = useRef<any>(null);
  const priceHistoryRef = useRef<Map<string, number[]>>(new Map());
  
  // åˆå§‹åŒ–å®¢æˆ·ç«¯
  useEffect(() => {
    clientRef.current = createPublicClient({
      chain: mainnet, // æˆ– zetachainAthens
      transport: http(),
    });
    
    setState(prev => ({ ...prev, isConnected: true }));
    
    return () => {
      setState(prev => ({ ...prev, isConnected: false }));
    };
  }, []);
  
  // ç›‘æ§å¤§é¢è½¬è´¦
  const monitorLargeTransfers = useCallback(async () => {
    if (!clientRef.current) return;
    
    try {
      // è·å–æœ€æ–°åŒºå—çš„è½¬è´¦äº‹ä»¶
      const latestBlock = await clientRef.current.getBlockNumber();
      
      // ERC20 Transfer äº‹ä»¶ç­¾å
      const transferEventAbi = parseAbi([
        'event Transfer(address indexed from, address indexed to, uint256 value)'
      ]);
      
      for (const token of MONITOR_CONFIG.watchedTokens) {
        const logs = await clientRef.current.getLogs({
          address: token.address as `0x${string}`,
          event: transferEventAbi[0],
          fromBlock: latestBlock - BigInt(10),
          toBlock: latestBlock,
        });
        
        for (const log of logs) {
          const value = Number(formatEther(log.args.value || BigInt(0)));
          const valueUsd = value * await getTokenPrice(token.symbol);
          
          if (valueUsd >= MONITOR_CONFIG.largeTradeThreshold) {
            const event: ChainEvent = {
              type: isKnownDex(log.args.to) ? 'large_sell' : 
                    isKnownDex(log.args.from) ? 'large_buy' : 'whale_transfer',
              token: token.symbol,
              value: valueUsd,
              from: log.args.from,
              to: log.args.to,
              timestamp: Date.now(),
              txHash: log.transactionHash,
            };
            
            addEvent(event);
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºé²¸é±¼
            if (MONITOR_CONFIG.watchedWhales.includes(log.args.from || '') ||
                MONITOR_CONFIG.watchedWhales.includes(log.args.to || '')) {
              setState(prev => ({
                ...prev,
                whaleAlert: {
                  address: log.args.from || log.args.to || '',
                  amount: valueUsd,
                  token: token.symbol,
                  direction: isKnownDex(log.args.to) ? 'out' : 'in',
                  timestamp: Date.now(),
                },
              }));
            }
          }
        }
      }
    } catch (error) {
      console.error('ç›‘æ§å¤§é¢è½¬è´¦å¤±è´¥:', error);
    }
  }, []);
  
  // ç›‘æ§ä»·æ ¼å˜åŒ–
  const monitorPriceChanges = useCallback(async () => {
    try {
      for (const token of MONITOR_CONFIG.watchedTokens) {
        const currentPrice = await getTokenPrice(token.symbol);
        const history = priceHistoryRef.current.get(token.symbol) || [];
        
        // ä¿å­˜å†å²ä»·æ ¼ (æœ€è¿‘ 60 ä¸ªæ•°æ®ç‚¹)
        history.push(currentPrice);
        if (history.length > 60) history.shift();
        priceHistoryRef.current.set(token.symbol, history);
        
        // è®¡ç®— 5 åˆ†é’Ÿä»·æ ¼å˜åŒ–
        if (history.length >= 30) {
          const oldPrice = history[0];
          const change = ((currentPrice - oldPrice) / oldPrice) * 100;
          
          if (Math.abs(change) >= MONITOR_CONFIG.priceAlertThreshold) {
            setState(prev => ({ ...prev, priceChange: change }));
            
            addEvent({
              type: 'price_change',
              token: token.symbol,
              value: change,
              timestamp: Date.now(),
            });
          }
        }
      }
    } catch (error) {
      console.error('ç›‘æ§ä»·æ ¼å˜åŒ–å¤±è´¥:', error);
    }
  }, []);
  
  // ç›‘æ§ Gas ä»·æ ¼
  const monitorGasPrice = useCallback(async () => {
    if (!clientRef.current) return;
    
    try {
      const gasPrice = await clientRef.current.getGasPrice();
      setState(prev => ({ ...prev, gasPrice }));
    } catch (error) {
      console.error('è·å– Gas ä»·æ ¼å¤±è´¥:', error);
    }
  }, []);
  
  // æ·»åŠ äº‹ä»¶
  const addEvent = useCallback((event: ChainEvent) => {
    setState(prev => ({
      ...prev,
      latestEvent: event,
      events: [event, ...prev.events].slice(0, 50), // ä¿ç•™æœ€è¿‘ 50 æ¡
    }));
  }, []);
  
  // å¯åŠ¨ç›‘æ§
  useEffect(() => {
    const interval = setInterval(() => {
      monitorLargeTransfers();
      monitorPriceChanges();
      monitorGasPrice();
    }, MONITOR_CONFIG.pollInterval);
    
    // ç«‹å³æ‰§è¡Œä¸€æ¬¡
    monitorLargeTransfers();
    monitorPriceChanges();
    monitorGasPrice();
    
    return () => clearInterval(interval);
  }, [monitorLargeTransfers, monitorPriceChanges, monitorGasPrice]);
  
  // æ‰‹åŠ¨åˆ·æ–°
  const refresh = useCallback(() => {
    monitorLargeTransfers();
    monitorPriceChanges();
    monitorGasPrice();
  }, [monitorLargeTransfers, monitorPriceChanges, monitorGasPrice]);
  
  // æ¸…é™¤è­¦æŠ¥
  const clearAlerts = useCallback(() => {
    setState(prev => ({
      ...prev,
      latestEvent: null,
      whaleAlert: null,
      priceChange: 0,
    }));
  }, []);
  
  return {
    ...state,
    refresh,
    clearAlerts,
  };
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–ä»£å¸ä»·æ ¼
async function getTokenPrice(symbol: string): Promise<number> {
  try {
    // å¯ä»¥æ¥å…¥ CoinGeckoã€Chainlink ç­‰ä»·æ ¼æº
    const response = await fetch(
      `https://api.coingecko.com/api/v3/simple/price?ids=${getCoingeckoId(symbol)}&vs_currencies=usd`
    );
    const data = await response.json();
    return data[getCoingeckoId(symbol)]?.usd || 0;
  } catch {
    return 0;
  }
}

function getCoingeckoId(symbol: string): string {
  const mapping: Record<string, string> = {
    'ETH': 'ethereum',
    'ZETA': 'zetachain',
    'BTC': 'bitcoin',
  };
  return mapping[symbol] || symbol.toLowerCase();
}

function isKnownDex(address?: string): boolean {
  if (!address) return false;
  const dexAddresses = [
    '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D', // Uniswap V2 Router
    '0xE592427A0AEce92De3Edee1F18E0157C05861564', // Uniswap V3 Router
    // ... æ›´å¤š DEX åœ°å€
  ];
  return dexAddresses.includes(address.toLowerCase());
}
```

---

## ğŸ® äº”ã€äº’åŠ¨ç³»ç»Ÿ

```typescript
// src/hooks/useFrogInteraction.ts

import { useState, useCallback, useRef } from 'react';
import { FrogState, FrogMood } from '../types/frogAnimation';

interface InteractionStats {
  totalClicks: number;
  totalPets: number;
  totalFeeds: number;
  totalTravels: number;
  lastInteraction: number;
}

export function useFrogInteraction() {
  const [stats, setStats] = useState<InteractionStats>({
    totalClicks: 0,
    totalPets: 0,
    totalFeeds: 0,
    totalTravels: 0,
    lastInteraction: Date.now(),
  });
  
  const clickTimestamps = useRef<number[]>([]);
  
  // è®°å½•ç‚¹å‡»
  const recordClick = useCallback(() => {
    const now = Date.now();
    
    // æ¸…ç† 2 ç§’å‰çš„ç‚¹å‡»è®°å½•
    clickTimestamps.current = clickTimestamps.current.filter(
      ts => now - ts < 2000
    );
    clickTimestamps.current.push(now);
    
    setStats(prev => ({
      ...prev,
      totalClicks: prev.totalClicks + 1,
      lastInteraction: now,
    }));
    
    return clickTimestamps.current.length;
  }, []);
  
  // æŠšæ‘¸
  const pet = useCallback(() => {
    setStats(prev => ({
      ...prev,
      totalPets: prev.totalPets + 1,
      lastInteraction: Date.now(),
    }));
  }, []);
  
  // å–‚é£Ÿ
  const feed = useCallback((foodType: string) => {
    setStats(prev => ({
      ...prev,
      totalFeeds: prev.totalFeeds + 1,
      lastInteraction: Date.now(),
    }));
    
    // è¿”å›å–‚é£Ÿæ•ˆæœ
    const effects: Record<string, { energy: number; happiness: number }> = {
      'fly': { energy: 10, happiness: 5 },      // è‹è‡ - æ™®é€š
      'worm': { energy: 20, happiness: 10 },    // è™«å­ - å¥½åƒ
      'cricket': { energy: 30, happiness: 15 }, // èŸ‹èŸ€ - ç¾å‘³
      'golden_fly': { energy: 50, happiness: 30 }, // é‡‘è‹è‡ - ç¨€æœ‰
    };
    
    return effects[foodType] || { energy: 5, happiness: 2 };
  }, []);
  
  // æ£€æŸ¥æ˜¯å¦éœ€è¦æ³¨æ„åŠ›
  const needsAttention = useCallback(() => {
    const timeSinceLastInteraction = Date.now() - stats.lastInteraction;
    return timeSinceLastInteraction > 5 * 60 * 1000; // 5 åˆ†é’Ÿæ²¡äº’åŠ¨
  }, [stats.lastInteraction]);
  
  // è·å–äº’åŠ¨å»ºè®®
  const getSuggestion = useCallback((): string => {
    if (needsAttention()) {
      return 'æˆ‘æœ‰ç‚¹æ— èŠ...æ¥ç©ç©å§ï¼';
    }
    
    const suggestions = [
      'ç‚¹å‡»æˆ‘å¯ä»¥äº’åŠ¨å“¦ï¼',
      'åŒå‡»æœ‰æƒŠå–œ~',
      'å¯ä»¥æ‹–åŠ¨æˆ‘ç§»åŠ¨ä½ç½®ï¼',
      'ç»™æˆ‘æ‰¾ç‚¹è™«å­åƒå§~',
      'æƒ³ä¸æƒ³æ´¾æˆ‘å»æ—…è¡Œï¼Ÿ',
    ];
    
    return suggestions[Math.floor(Math.random() * suggestions.length)];
  }, [needsAttention]);
  
  return {
    stats,
    recordClick,
    pet,
    feed,
    needsAttention,
    getSuggestion,
  };
}
```

---

## ğŸ½ï¸ å…­ã€å–‚é£Ÿç³»ç»Ÿ

```tsx
// src/components/frog/FeedingSystem.tsx

import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useFrogInteraction } from '../../hooks/useFrogInteraction';

interface FoodItem {
  id: string;
  name: string;
  emoji: string;
  rarity: 'common' | 'uncommon' | 'rare' | 'legendary';
  energy: number;
  happiness: number;
}

const FOOD_ITEMS: FoodItem[] = [
  { id: 'fly', name: 'è‹è‡', emoji: 'ğŸª°', rarity: 'common', energy: 10, happiness: 5 },
  { id: 'worm', name: 'è™«å­', emoji: 'ğŸª±', rarity: 'common', energy: 15, happiness: 8 },
  { id: 'cricket', name: 'èŸ‹èŸ€', emoji: 'ğŸ¦—', rarity: 'uncommon', energy: 25, happiness: 15 },
  { id: 'butterfly', name: 'è´è¶', emoji: 'ğŸ¦‹', rarity: 'uncommon', energy: 20, happiness: 20 },
  { id: 'dragonfly', name: 'èœ»èœ“', emoji: 'ğŸª°', rarity: 'rare', energy: 35, happiness: 25 },
  { id: 'golden_fly', name: 'é‡‘è‹è‡', emoji: 'âœ¨ğŸª°', rarity: 'legendary', energy: 50, happiness: 40 },
];

interface FeedingSystemProps {
  onFeed: (food: FoodItem) => void;
  inventory: Record<string, number>;
}

export function FeedingSystem({ onFeed, inventory }: FeedingSystemProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [selectedFood, setSelectedFood] = useState<FoodItem | null>(null);
  
  const rarityColors = {
    common: 'bg-gray-100 border-gray-300',
    uncommon: 'bg-green-100 border-green-300',
    rare: 'bg-blue-100 border-blue-300',
    legendary: 'bg-yellow-100 border-yellow-300',
  };
  
  const handleFeed = (food: FoodItem) => {
    if ((inventory[food.id] || 0) <= 0) return;
    
    setSelectedFood(food);
    onFeed(food);
    
    // æ’­æ”¾å–‚é£ŸåŠ¨ç”»
    setTimeout(() => {
      setSelectedFood(null);
    }, 1000);
  };
  
  return (
    <div className="relative">
      {/* å–‚é£ŸæŒ‰é’® */}
      <motion.button
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
        onClick={() => setIsOpen(!isOpen)}
        className="w-12 h-12 bg-orange-500 hover:bg-orange-600 rounded-full shadow-lg flex items-center justify-center text-2xl"
      >
        ğŸ½ï¸
      </motion.button>
      
      {/* é£Ÿç‰©èœå• */}
      <AnimatePresence>
        {isOpen && (
          <motion.div
            initial={{ opacity: 0, scale: 0.8, y: 10 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.8, y: 10 }}
            className="absolute bottom-full left-0 mb-2 bg-white rounded-2xl shadow-xl p-4 min-w-[200px]"
          >
            <h3 className="font-bold text-gray-800 mb-3">å–‚é£Ÿ</h3>
            
            <div className="space-y-2">
              {FOOD_ITEMS.map((food) => {
                const count = inventory[food.id] || 0;
                
                return (
                  <motion.button
                    key={food.id}
                    whileHover={{ x: 5 }}
                    onClick={() => handleFeed(food)}
                    disabled={count <= 0}
                    className={`
                      w-full flex items-center gap-3 p-2 rounded-xl border-2
                      ${rarityColors[food.rarity]}
                      ${count <= 0 ? 'opacity-50 cursor-not-allowed' : 'hover:shadow-md'}
                      transition-all
                    `}
                  >
                    <span className="text-2xl">{food.emoji}</span>
                    <div className="flex-1 text-left">
                      <p className="font-medium text-gray-800">{food.name}</p>
                      <p className="text-xs text-gray-500">
                        âš¡{food.energy} ğŸ˜Š{food.happiness}
                      </p>
                    </div>
                    <span className="text-sm font-bold text-gray-600">
                      x{count}
                    </span>
                  </motion.button>
                );
              })}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
      
      {/* å–‚é£ŸåŠ¨ç”» */}
      <AnimatePresence>
        {selectedFood && (
          <motion.div
            initial={{ opacity: 1, y: 0 }}
            animate={{ opacity: 0, y: -50 }}
            exit={{ opacity: 0 }}
            className="absolute -top-10 left-1/2 -translate-x-1/2 text-3xl"
          >
            {selectedFood.emoji}
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
```

---

## ğŸ“Š ä¸ƒã€é“¾ä¸Šäº‹ä»¶é€šçŸ¥é¢æ¿

```tsx
// src/components/frog/ChainEventPanel.tsx

import { motion, AnimatePresence } from 'framer-motion';
import { useChainMonitor } from '../../hooks/useChainMonitor';
import { formatDistanceToNow } from 'date-fns';
import { zhCN } from 'date-fns/locale';

export function ChainEventPanel() {
  const { events, gasPrice, isConnected, refresh } = useChainMonitor();
  
  const eventIcons: Record<string, string> = {
    large_buy: 'ğŸŸ¢',
    large_sell: 'ğŸ”´',
    whale_transfer: 'ğŸ‹',
    new_listing: 'ğŸ†•',
    price_change: 'ğŸ“Š',
  };
  
  const eventLabels: Record<string, string> = {
    large_buy: 'å¤§å•ä¹°å…¥',
    large_sell: 'å¤§å•å–å‡º',
    whale_transfer: 'é²¸é±¼è½¬è´¦',
    new_listing: 'æ–°é¡¹ç›®',
    price_change: 'ä»·æ ¼å˜åŠ¨',
  };
  
  return (
    <motion.div
      initial={{ opacity: 0, x: 20 }}
      animate={{ opacity: 1, x: 0 }}
      className="fixed right-4 top-20 w-80 bg-white/90 backdrop-blur-sm rounded-2xl shadow-xl overflow-hidden"
    >
      {/* å¤´éƒ¨ */}
      <div className="bg-gradient-to-r from-green-500 to-emerald-600 p-4">
        <div className="flex items-center justify-between">
          <h3 className="font-bold text-white flex items-center gap-2">
            â›“ï¸ é“¾ä¸Šç›‘æ§
            <span className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-300' : 'bg-red-400'}`} />
          </h3>
          <motion.button
            whileHover={{ rotate: 180 }}
            onClick={refresh}
            className="text-white/80 hover:text-white"
          >
            ğŸ”„
          </motion.button>
        </div>
        
        {/* Gas ä»·æ ¼ */}
        <div className="mt-2 text-sm text-white/80">
          â›½ Gas: {Number(gasPrice / BigInt(1e9)).toFixed(1)} Gwei
        </div>
      </div>
      
      {/* äº‹ä»¶åˆ—è¡¨ */}
      <div className="max-h-96 overflow-y-auto p-4 space-y-3">
        <AnimatePresence>
          {events.length === 0 ? (
            <div className="text-center text-gray-400 py-8">
              <p className="text-4xl mb-2">ğŸ¸</p>
              <p>æš‚æ— äº‹ä»¶</p>
              <p className="text-xs">é’è›™æ­£åœ¨ç›‘æ§ä¸­...</p>
            </div>
          ) : (
            events.map((event, index) => (
              <motion.div
                key={`${event.timestamp}-${index}`}
                initial={{ opacity: 0, y: -20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, x: 20 }}
                className="bg-gray-50 rounded-xl p-3"
              >
                <div className="flex items-start gap-3">
                  <span className="text-xl">{eventIcons[event.type]}</span>
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2">
                      <span className="font-medium text-gray-800">
                        {eventLabels[event.type]}
                      </span>
                      <span className="text-xs text-gray-400">
                        {formatDistanceToNow(event.timestamp, { 
                          addSuffix: true, 
                          locale: zhCN 
                        })}
                      </span>
                    </div>
                    <p className="text-sm text-gray-600 truncate">
                      {event.type === 'price_change' 
                        ? `${event.token} ${event.value > 0 ? 'ğŸ“ˆ' : 'ğŸ“‰'} ${event.value.toFixed(2)}%`
                        : `${formatValue(event.value)} ${event.token}`
                      }
                    </p>
                    {event.txHash && (
                      <a
                        href={`https://etherscan.io/tx/${event.txHash}`}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-xs text-green-600 hover:underline"
                      >
                        æŸ¥çœ‹äº¤æ˜“ â†—
                      </a>
                    )}
                  </div>
                </div>
              </motion.div>
            ))
          )}
        </AnimatePresence>
      </div>
    </motion.div>
  );
}

function formatValue(value: number): string {
  if (value >= 1000000) return `\${(value / 1000000).toFixed(2)}M`;
  if (value >= 1000) return `\${(value / 1000).toFixed(2)}K`;
  return `\${value.toFixed(2)}`;
}
```

---

## ğŸ¯ å…«ã€å®Œæ•´é›†æˆç¤ºä¾‹

```tsx
// src/pages/Desktop.tsx

import { useState } from 'react';
import { FrogPet } from '../components/frog/FrogPet';
import { ChainEventPanel } from '../components/frog/ChainEventPanel';
import { FeedingSystem } from '../components/frog/FeedingSystem';
import { ConnectButton } from '../components/wallet/ConnectButton';
import { useWallet } from '../hooks/useWallet';
import { useFrogData } from '../hooks/useFrogData';

export function Desktop() {
  const { isConnected, address } = useWallet();
  const { frogs, activeFrog } = useFrogData(address);
  
  const [inventory, setInventory] = useState({
    fly: 10,
    worm: 5,
    cricket: 3,
    butterfly: 2,
    dragonfly: 1,
    golden_fly: 0,
  });
  
  const handleFeed = (food: any) => {
    setInventory(prev => ({
      ...prev,
      [food.id]: Math.max(0, (prev[food.id] || 0) - 1),
    }));
  };
  
  const handleInteract = (interaction: string) => {
    console.log('Interaction:', interaction);
  };
  
  return (
    <div className="min-h-screen bg-gradient-to-b from-sky-200 via-green-100 to-green-200 relative overflow-hidden">
      {/* èƒŒæ™¯è£…é¥° */}
      <div className="absolute inset-0 pointer-events-none">
        {/* äº‘æœµ */}
        <div className="absolute top-10 left-10 text-6xl opacity-50">â˜ï¸</div>
        <div className="absolute top-20 right-20 text-4xl opacity-40">â˜ï¸</div>
        <div className="absolute top-5 left-1/2 text-5xl opacity-45">â˜ï¸</div>
        
        {/* è‰åœ° */}
        <div className="absolute bottom-0 left-0 right-0 h-32 bg-gradient-to-t from-green-500 to-transparent" />
      </div>
      
      {/* é¡¶éƒ¨å¯¼èˆª */}
      <nav className="fixed top-0 left-0 right-0 z-50 bg-white/80 backdrop-blur-sm border-b border-gray-200">
        <div className="max-w-7xl mx-auto px-6 py-4 flex items-center justify-between">
          <div className="flex items-center gap-3">
            <span className="text-3xl">ğŸ¸</span>
            <span className="font-bold text-xl text-gray-800">ZetaFrog Desktop</span>
          </div>
          <ConnectButton />
        </div>
      </nav>
      
      {/* ä¸»è¦å†…å®¹ */}
      <main className="pt-24 pb-12 px-6 relative z-10">
        <div className="max-w-7xl mx-auto">
          {/* é’è›™åŒºåŸŸ */}
          <div className="flex justify-center items-center min-h-[60vh]">
            {activeFrog ? (
              <FrogPet
                frogId={activeFrog.id}
                name={activeFrog.name}
                initialState={activeFrog.status}
                onInteract={handleInteract}
              />
            ) : (
              <div className="text-center">
                <p className="text-6xl mb-4">ğŸ¥š</p>
                <p className="text-gray-600">ä½ è¿˜æ²¡æœ‰é’è›™</p>
                <p className="text-sm text-gray-400">è¿æ¥é’±åŒ…å¹¶é“¸é€ ä¸€åªå§ï¼</p>
              </div>
            )}
          </div>
        </div>
      </main>
      
      {/* å–‚é£Ÿç³»ç»Ÿ */}
      <div className="fixed left-4 bottom-4 z-40">
        <FeedingSystem 
          onFeed={handleFeed}
          inventory={inventory}
        />
      </div>
      
      {/* é“¾ä¸Šç›‘æ§é¢æ¿ */}
      <ChainEventPanel />
      
      {/* å¿«æ·æ“ä½œæ  */}
      <div className="fixed bottom-4 left-1/2 -translate-x-1/2 z-40">
        <div className="flex gap-3 bg-white/90 backdrop-blur-sm rounded-full px-6 py-3 shadow-lg">
          <ActionButton emoji="ğŸ’" label="æ—…è¡Œ" />
          <ActionButton emoji="ğŸ“–" label="æ—¥è®°" />
          <ActionButton emoji="ğŸ" label="çºªå¿µå“" />
          <ActionButton emoji="âš™ï¸" label="è®¾ç½®" />
        </div>
      </div>
    </div>
  );
}

function ActionButton({ emoji, label }: { emoji: string; label: string }) {
  return (
    <motion.button
      whileHover={{ scale: 1.1, y: -2 }}
      whileTap={{ scale: 0.95 }}
      className="flex flex-col items-center gap-1 px-3"
    >
      <span className="text-2xl">{emoji}</span>
      <span className="text-xs text-gray-600">{label}</span>
    </motion.button>
  );
}
```

---

## ğŸ“‹ åˆ›æ„åŠŸèƒ½æ€»ç»“

| åŠŸèƒ½æ¨¡å— | ç‰¹è‰² | äº’åŠ¨æ–¹å¼ |
|---------|------|---------|
| **çŠ¶æ€åŠ¨ç”»** | 15+ ç§é’è›™çŠ¶æ€ï¼Œä¸°å¯Œè¡¨æƒ… | è‡ªåŠ¨åˆ‡æ¢ |
| **ç²’å­æ•ˆæœ** | æ˜Ÿæ˜Ÿã€é‡‘å¸ã€çˆ±å¿ƒã€éŸ³ç¬¦ç­‰ | äº‹ä»¶è§¦å‘ |
| **å¯¹è¯æ°”æ³¡** | æ‰“å­—æœºæ•ˆæœï¼Œæ™ºèƒ½å¯¹è¯ | äº’åŠ¨è§¦å‘ |
| **é“¾ä¸Šç›‘æ§** | å¤§å•æ£€æµ‹ã€é²¸é±¼è¿½è¸ªã€ä»·æ ¼è­¦æŠ¥ | å®æ—¶æ¨é€ |
| **å–‚é£Ÿç³»ç»Ÿ** | å¤šç§é£Ÿç‰©ï¼Œç¨€æœ‰åº¦æœºåˆ¶ | ä¸»åŠ¨å–‚é£Ÿ |
| **ç‚¹å‡»äº’åŠ¨** | å•å‡»ã€åŒå‡»ã€è¿å‡»ååº” | ç”¨æˆ·æ“ä½œ |
| **æ‹–æ‹½ç§»åŠ¨** | å¯æ‹–åŠ¨åˆ°ä»»æ„ä½ç½® | ç”¨æˆ·æ“ä½œ |
| **å¿ƒæƒ…ç³»ç»Ÿ** | æ ¹æ®äº’åŠ¨å’Œäº‹ä»¶å˜åŒ– | ç»¼åˆè®¡ç®— |

è¿™ä¸ªæ–¹æ¡ˆå°† **æ¡Œé¢å® ç‰©çš„è¶£å‘³æ€§** ä¸ **Web3 é“¾ä¸Šæ•°æ®** å®Œç¾ç»“åˆï¼Œè®©ç”¨æˆ·åœ¨å…»æˆé’è›™çš„åŒæ—¶å®æ—¶äº†è§£å¸‚åœºåŠ¨æ€ï¼ğŸ¸â›“ï¸